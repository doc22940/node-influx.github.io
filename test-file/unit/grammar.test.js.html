<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">unit/grammar.test.js | node-influx API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/builder.js~Expression.html">Expression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/builder.js~Measurement.html">Measurement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/index.js~InfluxDB.html">InfluxDB</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/pool.js~Pool.html">Pool</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/pool.js~RequestError.html">RequestError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/pool.js~ServiceNotAvailableError.html">ServiceNotAvailableError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/results.js~ResultError.html">ResultError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/src/doc.js~IBackoffStrategy.html">IBackoffStrategy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/src/doc.js~INanoDate.html">INanoDate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/src/doc.js~IResults.html">IResults</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-IClusterConfig">IClusterConfig</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-IPingStats">IPingStats</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-IPoint">IPoint</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-IPoolOptions">IPoolOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-IQueryOptions">IQueryOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ISchemaOptions">ISchemaOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ISingleHostConfig">ISingleHostConfig</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-IWriteOptions">IWriteOptions</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">backoff</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/backoff/exponential.js~ExponentialBackoff.html">ExponentialBackoff</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">grammar</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/grammar/ds.js~Raw.html">Raw</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-toNanoDate">toNanoDate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-escape">escape</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Precision">Precision</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-FieldType">FieldType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-FieldType">FieldType</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">unit/grammar.test.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import { expect } from &apos;chai&apos;;
import * as grammar from &apos;../../src/grammar&apos;;
const escapeTables = require(&apos;../fixture/escapeTables.json&apos;);
describe(&apos;grammar&apos;, () =&gt; {
    Object.keys(escapeTables).forEach(escaper =&gt; {
        describe(escaper, () =&gt; {
            escapeTables[escaper].forEach(test =&gt; {
                it(`escapes \`${test[0]}\` as \`${test[1]}\``, () =&gt; {
                    expect(grammar.escape[escaper](test[0])).to.equal(test[1]);
                });
            });
        });
    });
    it(&apos;does not escape raw values&apos;, () =&gt; {
        expect(grammar.escape.quoted(new grammar.Raw(&apos;don&quot;t escape&apos;))).to.equal(&apos;don&quot;t escape&apos;);
    });
    it(&apos;escapes complex values (issue #242)&apos;, () =&gt; {
        const original = JSON.stringify({ a: JSON.stringify({ b: &apos;c c&apos; }) });
        expect(grammar.escape.quoted(original))
            .to.equal(&apos;&quot;{\\&quot;a\\&quot;:\\&quot;{\\\\\\&quot;b\\\\\\&quot;:\\\\\\&quot;c c\\\\\\&quot;}\\&quot;}&quot;&apos;);
    });
    let nanoDate;
    let milliDate;
    beforeEach(() =&gt; {
        nanoDate = grammar.isoOrTimeToDate(&apos;2016-10-09T03:58:00.231035677Z&apos;, &apos;n&apos;);
        milliDate = new Date(1475985480231);
    });
    it(&apos;converts a nanoseconds timestamp to a nano date&apos;, () =&gt; {
        const date = grammar.toNanoDate(&apos;1475985480231035600&apos;);
        expect(date.getTime()).to.equal(1475985480231);
        expect(date.getNanoTime()).to.equal(&apos;1475985480231035600&apos;); // precision is lost
        expect(date.toNanoISOString()).to.equal(&apos;2016-10-09T03:58:00.231035600Z&apos;);
    });
    describe(&apos;formatting&apos;, () =&gt; {
        it(&apos;formats nanosecond dates&apos;, () =&gt; {
            expect(grammar.formatDate(nanoDate)).to.equal(&apos;&quot;2016-10-09 03:58:00.231035677&quot;&apos;);
        });
        it(&apos;formats millisecond dates&apos;, () =&gt; {
            expect(grammar.formatDate(milliDate)).to.equal(&apos;&quot;2016-10-09 03:58:00.231&quot;&apos;);
        });
    });
    describe(&apos;parsing&apos;, () =&gt; {
        it(&apos;parses ISO dates correctly&apos;, () =&gt; {
            const parsed = grammar.isoOrTimeToDate(&apos;2016-10-09T03:58:00.231035677Z&apos;, &apos;n&apos;);
            expect(parsed.getTime()).to.equal(1475985480231);
            expect(parsed.getNanoTime()).to.equal(&apos;1475985480231035677&apos;);
            expect(parsed.toNanoISOString()).to.equal(&apos;2016-10-09T03:58:00.231035677Z&apos;);
        });
        it(&apos;parses numeric `ns` timestamps&apos;, () =&gt; {
            const parsed = grammar.isoOrTimeToDate(1475985480231035677, &apos;n&apos;);
            expect(parsed.getTime()).to.equal(1475985480231);
            expect(parsed.getNanoTime()).to.equal(&apos;1475985480231035600&apos;); // precision is lost
            expect(parsed.toNanoISOString()).to.equal(&apos;2016-10-09T03:58:00.231035600Z&apos;);
        });
        it(&apos;parses numeric `u` timestamps&apos;, () =&gt; {
            const parsed = grammar.isoOrTimeToDate(1475985480231035, &apos;u&apos;);
            expect(parsed.getTime()).to.equal(1475985480231);
            expect(parsed.getNanoTime()).to.equal(&apos;1475985480231035000&apos;);
            expect(parsed.toNanoISOString()).to.equal(&apos;2016-10-09T03:58:00.231035000Z&apos;);
        });
        it(&apos;parses numeric `ms` timestamps&apos;, () =&gt; {
            const parsed = grammar.isoOrTimeToDate(1475985480231, &apos;ms&apos;);
            expect(parsed.getTime()).to.equal(1475985480231);
            expect(parsed.getNanoTime()).to.equal(&apos;1475985480231000000&apos;);
        });
        it(&apos;parses numeric `s` timestamps&apos;, () =&gt; {
            const parsed = grammar.isoOrTimeToDate(1475985480, &apos;s&apos;);
            expect(parsed.getTime()).to.equal(1475985480000);
            expect(parsed.getNanoTime()).to.equal(&apos;1475985480000000000&apos;);
        });
        it(&apos;parses numeric `m` timestamps&apos;, () =&gt; {
            const parsed = grammar.isoOrTimeToDate(24599758, &apos;m&apos;);
            expect(parsed.getTime()).to.equal(1475985480000);
            expect(parsed.getNanoTime()).to.equal(&apos;1475985480000000000&apos;);
        });
        it(&apos;parses numeric `h` timestamps&apos;, () =&gt; {
            const parsed = grammar.isoOrTimeToDate(409995, &apos;h&apos;);
            expect(parsed.getTime()).to.equal(1475982000000);
            expect(parsed.getNanoTime()).to.equal(&apos;1475982000000000000&apos;);
        });
    });
    describe(&apos;timestamp casting&apos;, () =&gt; {
        it(&apos;casts dates into timestamps&apos;, () =&gt; {
            const d = new Date(1475121809084);
            expect(grammar.castTimestamp(d, &apos;n&apos;)).to.equal(&apos;1475121809084000000&apos;);
            expect(grammar.castTimestamp(d, &apos;u&apos;)).to.equal(&apos;1475121809084000&apos;);
            expect(grammar.castTimestamp(d, &apos;ms&apos;)).to.equal(&apos;1475121809084&apos;);
            expect(grammar.castTimestamp(d, &apos;s&apos;)).to.equal(&apos;1475121809&apos;);
            expect(grammar.castTimestamp(d, &apos;m&apos;)).to.equal(&apos;24585363&apos;);
            expect(grammar.castTimestamp(d, &apos;h&apos;)).to.equal(&apos;409756&apos;);
        });
        it(&apos;casts nanodates into timestamps&apos;, () =&gt; {
            const d = grammar.toNanoDate(&apos;1475985480231035600&apos;);
            expect(grammar.castTimestamp(d, &apos;n&apos;)).to.equal(&apos;1475985480231035600&apos;);
            expect(grammar.castTimestamp(d, &apos;u&apos;)).to.equal(&apos;1475985480231035&apos;);
            expect(grammar.castTimestamp(d, &apos;ms&apos;)).to.equal(&apos;1475985480231&apos;);
            expect(grammar.castTimestamp(d, &apos;s&apos;)).to.equal(&apos;1475985480&apos;);
            expect(grammar.castTimestamp(d, &apos;m&apos;)).to.equal(&apos;24599758&apos;);
            expect(grammar.castTimestamp(d, &apos;h&apos;)).to.equal(&apos;409995&apos;);
        });
        it(&apos;accepts strings, numbers liternally&apos;, () =&gt; {
            expect(grammar.castTimestamp(&apos;1475985480231035600&apos;, &apos;s&apos;)).to.equal(&apos;1475985480231035600&apos;);
            expect(grammar.castTimestamp(1475985480231, &apos;s&apos;)).to.equal(&apos;1475985480231&apos;);
        });
        it(&apos;throws on non-numeric strings&apos;, () =&gt; {
            expect(() =&gt; grammar.castTimestamp(&apos;wut&apos;, &apos;s&apos;)).to.throw(/numeric value/);
        });
    });
});
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.8)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
