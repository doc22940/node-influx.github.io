[
  {
    "__docId__": 0,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/backoff/backoff.js",
    "memberof": null,
    "longname": "src/backoff/backoff.js",
    "access": null,
    "description": null,
    "lineNumber": 0,
    "content": "",
    "importPath": "influx"
  },
  {
    "__docId__": 1,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/backoff/exponential.js",
    "memberof": null,
    "longname": "src/backoff/exponential.js",
    "access": null,
    "description": null,
    "lineNumber": 5,
    "content": "/**\n * @class\n * @implements {IBackoffStrategy}\n */\nexport class ExponentialBackoff {\n    /**\n     * Creates a new exponential backoff strategy.\n     * @see https://en.wikipedia.org/wiki/Exponential_backoff\n     * @param {IExponentialOptions} options\n     */\n    constructor(options) {\n        this.options = options;\n        this.counter = 0;\n    }\n    /**\n     * @inheritDoc\n     */\n    getDelay() {\n        const count = this.counter - Math.round(Math.random() * this.options.random); // tslint:disable-line\n        return Math.min(this.options.max, this.options.initial * Math.pow(2, Math.max(count, 0)));\n    }\n    /**\n     * @inheritDoc\n     */\n    next() {\n        const next = new ExponentialBackoff(this.options);\n        next.counter = this.counter + 1;\n        return next;\n    }\n    /**\n     * @inheritDoc\n     */\n    reset() {\n        return new ExponentialBackoff(this.options);\n    }\n}\n",
    "importPath": "influx"
  },
  {
    "__docId__": 2,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "ExponentialBackoff",
    "memberof": "src/backoff/exponential.js",
    "longname": "src/backoff/exponential.js~ExponentialBackoff",
    "access": null,
    "export": true,
    "importPath": "influx",
    "importStyle": "{ExponentialBackoff}",
    "description": "",
    "lineNumber": 5,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false,
    "implements": [
      "IBackoffStrategy"
    ]
  },
  {
    "__docId__": 3,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/backoff/exponential.js~ExponentialBackoff",
    "longname": "src/backoff/exponential.js~ExponentialBackoff#constructor",
    "access": null,
    "description": "Creates a new exponential backoff strategy.",
    "see": [
      "https://en.wikipedia.org/wiki/Exponential_backoff"
    ],
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "IExponentialOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 4,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "options",
    "memberof": "src/backoff/exponential.js~ExponentialBackoff",
    "longname": "src/backoff/exponential.js~ExponentialBackoff#options",
    "access": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 5,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "counter",
    "memberof": "src/backoff/exponential.js~ExponentialBackoff",
    "longname": "src/backoff/exponential.js~ExponentialBackoff#counter",
    "access": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 6,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getDelay",
    "memberof": "src/backoff/exponential.js~ExponentialBackoff",
    "longname": "src/backoff/exponential.js~ExponentialBackoff#getDelay",
    "access": null,
    "description": "",
    "lineNumber": 18,
    "unknown": [
      {
        "tagName": "@inheritDoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 7,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "next",
    "memberof": "src/backoff/exponential.js~ExponentialBackoff",
    "longname": "src/backoff/exponential.js~ExponentialBackoff#next",
    "access": null,
    "description": "",
    "lineNumber": 25,
    "unknown": [
      {
        "tagName": "@inheritDoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 8,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "reset",
    "memberof": "src/backoff/exponential.js~ExponentialBackoff",
    "longname": "src/backoff/exponential.js~ExponentialBackoff#reset",
    "access": null,
    "description": "",
    "lineNumber": 33,
    "unknown": [
      {
        "tagName": "@inheritDoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 9,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/builder.js",
    "memberof": null,
    "longname": "src/builder.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import { escape, formatDate } from './grammar';\nfunction regexHasFlags(re) {\n    if (typeof re.flags !== 'undefined') {\n        return re.flags.length > 0;\n    }\n    return !(/\\/$/).test(re.toString());\n}\n/**\n * Expression is used to build filtering expressions, like those used in WHERE\n * clauses. It can be used for fluent and safe building of queries using\n * untrusted input.\n *\n * @example\n * e => e\n *   .field('host').equals.value('ares.peet.io')\n *   .or\n *   .field('host').matches(/example\\.com$/)\n *   .or\n *   .expr(e => e\n *     .field('country').equals.value('US')\n *     .and\n *     .field('state').equals.value('WA'));\n *\n * // Generates:\n * // \"host\" = 'ares.peet.io' OR \"host\" ~= /example\\.com$/ OR \\\n * //   (\"county\" = 'US' AND \"state\" = 'WA')\n */\nexport class Expression {\n    constructor() {\n        this.query = [];\n    }\n    /**\n     * Inserts a tag reference into the expression; the name will be\n     * automatically escaped.\n     * @param  {String} name\n     * @return {Expression}\n     */\n    tag(name) {\n        this.field(name);\n        return this;\n    }\n    /**\n     * Inserts a field reference into the expression; the name will be\n     * automatically escaped.\n     * @param  {String} name\n     * @return {Expression}\n     */\n    field(name) {\n        this.query.push(escape.quoted(name));\n        return this;\n    }\n    /**\n     * Inserts a subexpression; invokes the function with a new expression\n     * that can be chained on.\n     * @param  {function(e: Expression): Expression}  fn\n     * @return {Expression}\n     * @example\n     * e.field('a').equals.value('b')\n     *   .or.expr(e =>\n     *     e.field('b').equals.value('b')\n     *     .and.field('a').equals.value('c'))\n     *   .toString()\n     * // \"a\" = 'b' OR (\"b\" = 'b' AND \"a\" = 'c')\n     */\n    exp(fn) {\n        this.query.push('(' + fn(new Expression()).toString() + ')');\n        return this;\n    }\n    /**\n     * Value chains on a value to the expression.\n     *\n     *  - Numbers will be inserted verbatim\n     *  - Strings will be escaped and inserted\n     *  - Booleans will be inserted correctly\n     *  - Dates will be formatted and inserted correctly, including INanoDates.\n     *  - Regular expressions will be inserted correctly, however an error will\n     *    be thrown if they contain flags, as regex flags do not work in Influx\n     *  - Otherwise we'll try to call `.toString()` on the value, throwing\n     *    if we cannot do so.\n     *\n     * @param  {*}  value\n     * @return {Expression}\n     */\n    value(value) {\n        switch (typeof value) {\n            case 'number':\n                this.query.push(value);\n                return this;\n            case 'string':\n                this.query.push(escape.stringLit(value));\n                return this;\n            case 'boolean':\n                this.query.push(value ? 'TRUE' : 'FALSE');\n                return this;\n            default:\n                if (value instanceof Date) {\n                    this.query.push(formatDate(value));\n                    return this;\n                }\n                if (value instanceof RegExp) {\n                    if (regexHasFlags(value)) {\n                        throw new Error('Attempted to query using a regex with flags, ' +\n                            'but Influx doesn\\'t support flags in queries.');\n                    }\n                    this.query.push('/' + value.source + '/');\n                    return this;\n                }\n                if (value && typeof value.toString === 'function') {\n                    this.query.push(value.toString());\n                    return this;\n                }\n                throw new Error(`node-influx doesn't know how to encode the provided value into a ` +\n                    'query. If you think this is a bug, open an issue here: https://git.io/influx-err');\n        }\n    }\n    /**\n     * Chains on an AND clause to the expression.\n     * @type {Expression}\n     */\n    get and() {\n        this.query.push('AND');\n        return this;\n    }\n    /**\n     * Chains on an OR clause to the expression.\n     * @type {Expression}\n     */\n    get or() {\n        this.query.push('OR');\n        return this;\n    }\n    /**\n     * Chains on a `+` operator to the expression.\n     * @type {Expression}\n     */\n    get plus() {\n        this.query.push('+');\n        return this;\n    }\n    /**\n     * Chains on a `*` operator to the expression.\n     * @type {Expression}\n     */\n    get times() {\n        this.query.push('*');\n        return this;\n    }\n    /**\n     * Chains on a `-` operator to the expression.\n     * @type {Expression}\n     */\n    get minus() {\n        this.query.push('-');\n        return this;\n    }\n    /**\n     * Chains on a `/` operator to the expression.\n     * @type {Expression}\n     */\n    get div() {\n        this.query.push('/');\n        return this;\n    }\n    /**\n     * Chains on a `=` conditional to the expression.\n     * @type {Expression}\n     */\n    get equals() {\n        this.query.push('=');\n        return this;\n    }\n    /**\n     * Chains on a `=~` conditional to the expression to match regexes.\n     * @type {Expression}\n     */\n    get matches() {\n        this.query.push('=~');\n        return this;\n    }\n    /**\n     * Chains on a `!`` conditional to the expression to match regexes.\n     * @type {Expression}\n     */\n    get doesntMatch() {\n        this.query.push('!~');\n        return this;\n    }\n    /**\n     * Chains on a `!=` conditional to the expression.\n     * @type {Expression}\n     */\n    get notEqual() {\n        this.query.push('!=');\n        return this;\n    }\n    /**\n     * Chains on a `>` conditional to the expression.\n     * @type {Expression}\n     */\n    get gt() {\n        this.query.push('>');\n        return this;\n    }\n    /**\n     * Chains on a `>=` conditional to the expression.\n     * @type {Expression}\n     */\n    get gte() {\n        this.query.push('>=');\n        return this;\n    }\n    /**\n     * Chains on a `<` conditional to the expression.\n     * @type {Expression}\n     */\n    get lt() {\n        this.query.push('<');\n        return this;\n    }\n    /**\n     * Chains on a `<=` conditional to the expression.\n     * @type {Expression}\n     */\n    get lte() {\n        this.query.push('<=');\n        return this;\n    }\n    /**\n     * Converts the expression into its InfluxQL representation.\n     * @return {String}\n     */\n    toString() {\n        return this.query.join(' ');\n    }\n}\n/**\n * Measurement creates a reference to a particular measurement. You can\n * reference it solely by its name, but you can also specify the retention\n * policy and database it lives under.\n *\n * @example\n * m.name('my_measurement') // \"my_measurement\"\n * m.name('my_measurement').policy('one_day') // \"one_day\".\"my_measurement\"\n * m.name('my_measurement').policy('one_day').db('mydb') // \"mydb\".one_day\".\"my_measurement\"\n */\nexport class Measurement {\n    constructor() {\n        this.parts = [null, null, null];\n    }\n    /**\n     * Sets the measurement name.\n     * @param  {String} name\n     * @return {Measurement}\n     */\n    name(name) {\n        this.parts[2] = name;\n        return this;\n    }\n    /**\n     * Sets the retention policy name.\n     * @param  {String} retentionPolicy\n     * @return {Measurement}\n     */\n    policy(retentionPolicy) {\n        this.parts[1] = retentionPolicy;\n        return this;\n    }\n    /**\n     * Sets the database name.\n     * @param  {String} db\n     * @return {Measurement}\n     */\n    db(db) {\n        this.parts[0] = db;\n        return this;\n    }\n    /**\n     * Converts the measurement into its InfluxQL representation.\n     * @return {String}\n     * @throws {Error} if a measurement name is not provided\n     */\n    toString() {\n        if (!this.parts[2]) {\n            throw new Error(`You must specify a measurement name to query! Got \\`${this.parts[2]}\\``);\n        }\n        return this.parts.filter(p => !!p)\n            .map(p => escape.quoted(p))\n            .join('.');\n    }\n}\nexport function parseMeasurement(q) {\n    if (typeof q.measurement === 'function') {\n        return q.measurement(new Measurement()).toString();\n    }\n    return q.measurement;\n}\nexport function parseWhere(q) {\n    if (typeof q.where === 'function') {\n        return q.where(new Expression()).toString();\n    }\n    return q.where;\n}\n",
    "importPath": "influx"
  },
  {
    "__docId__": 10,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "regexHasFlags",
    "memberof": "src/builder.js",
    "longname": "src/builder.js~regexHasFlags",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "params": [
      {
        "name": "re",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 11,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "Expression",
    "memberof": "src/builder.js",
    "longname": "src/builder.js~Expression",
    "access": null,
    "export": true,
    "importPath": "influx",
    "importStyle": "{Expression}",
    "description": "Expression is used to build filtering expressions, like those used in WHERE\nclauses. It can be used for fluent and safe building of queries using\nuntrusted input.",
    "examples": [
      "e => e\n  .field('host').equals.value('ares.peet.io')\n  .or\n  .field('host').matches(/example\\.com$/)\n  .or\n  .expr(e => e\n    .field('country').equals.value('US')\n    .and\n    .field('state').equals.value('WA'));\n\n// Generates:\n// \"host\" = 'ares.peet.io' OR \"host\" ~= /example\\.com$/ OR \\\n//   (\"county\" = 'US' AND \"state\" = 'WA')"
    ],
    "lineNumber": 28,
    "interface": false
  },
  {
    "__docId__": 12,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#constructor",
    "access": null,
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "params": [],
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 13,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "query",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#query",
    "access": null,
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 14,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "tag",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#tag",
    "access": null,
    "description": "Inserts a tag reference into the expression; the name will be\nautomatically escaped.",
    "lineNumber": 38,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 15,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "field",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#field",
    "access": null,
    "description": "Inserts a field reference into the expression; the name will be\nautomatically escaped.",
    "lineNumber": 48,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 16,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "exp",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#exp",
    "access": null,
    "description": "Inserts a subexpression; invokes the function with a new expression\nthat can be chained on.",
    "examples": [
      "e.field('a').equals.value('b')\n  .or.expr(e =>\n    e.field('b').equals.value('b')\n    .and.field('a').equals.value('c'))\n  .toString()\n// \"a\" = 'b' OR (\"b\" = 'b' AND \"a\" = 'c')"
    ],
    "lineNumber": 65,
    "params": [
      {
        "nullable": null,
        "types": [
          "function(e: Expression): Expression"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 17,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "value",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#value",
    "access": null,
    "description": "Value chains on a value to the expression.\n\n - Numbers will be inserted verbatim\n - Strings will be escaped and inserted\n - Booleans will be inserted correctly\n - Dates will be formatted and inserted correctly, including INanoDates.\n - Regular expressions will be inserted correctly, however an error will\n   be thrown if they contain flags, as regex flags do not work in Influx\n - Otherwise we'll try to call `.toString()` on the value, throwing\n   if we cannot do so.",
    "lineNumber": 84,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 18,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "and",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#and",
    "access": null,
    "description": "Chains on an AND clause to the expression.",
    "lineNumber": 120,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 19,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "or",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#or",
    "access": null,
    "description": "Chains on an OR clause to the expression.",
    "lineNumber": 128,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 20,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "plus",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#plus",
    "access": null,
    "description": "Chains on a `+` operator to the expression.",
    "lineNumber": 136,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 21,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "times",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#times",
    "access": null,
    "description": "Chains on a `*` operator to the expression.",
    "lineNumber": 144,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 22,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "minus",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#minus",
    "access": null,
    "description": "Chains on a `-` operator to the expression.",
    "lineNumber": 152,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 23,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "div",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#div",
    "access": null,
    "description": "Chains on a `/` operator to the expression.",
    "lineNumber": 160,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 24,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "equals",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#equals",
    "access": null,
    "description": "Chains on a `=` conditional to the expression.",
    "lineNumber": 168,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 25,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "matches",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#matches",
    "access": null,
    "description": "Chains on a `=~` conditional to the expression to match regexes.",
    "lineNumber": 176,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 26,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "doesntMatch",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#doesntMatch",
    "access": null,
    "description": "Chains on a `!`` conditional to the expression to match regexes.",
    "lineNumber": 184,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 27,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "notEqual",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#notEqual",
    "access": null,
    "description": "Chains on a `!=` conditional to the expression.",
    "lineNumber": 192,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 28,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "gt",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#gt",
    "access": null,
    "description": "Chains on a `>` conditional to the expression.",
    "lineNumber": 200,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 29,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "gte",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#gte",
    "access": null,
    "description": "Chains on a `>=` conditional to the expression.",
    "lineNumber": 208,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 30,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "lt",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#lt",
    "access": null,
    "description": "Chains on a `<` conditional to the expression.",
    "lineNumber": 216,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 31,
    "kind": "get",
    "static": false,
    "variation": null,
    "name": "lte",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#lte",
    "access": null,
    "description": "Chains on a `<=` conditional to the expression.",
    "lineNumber": 224,
    "type": {
      "nullable": null,
      "types": [
        "Expression"
      ],
      "spread": false,
      "description": null
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 32,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "toString",
    "memberof": "src/builder.js~Expression",
    "longname": "src/builder.js~Expression#toString",
    "access": null,
    "description": "Converts the expression into its InfluxQL representation.",
    "lineNumber": 232,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 33,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "Measurement",
    "memberof": "src/builder.js",
    "longname": "src/builder.js~Measurement",
    "access": null,
    "export": true,
    "importPath": "influx",
    "importStyle": "{Measurement}",
    "description": "Measurement creates a reference to a particular measurement. You can\nreference it solely by its name, but you can also specify the retention\npolicy and database it lives under.",
    "examples": [
      "m.name('my_measurement') // \"my_measurement\"\nm.name('my_measurement').policy('one_day') // \"one_day\".\"my_measurement\"\nm.name('my_measurement').policy('one_day').db('mydb') // \"mydb\".one_day\".\"my_measurement\""
    ],
    "lineNumber": 246,
    "interface": false
  },
  {
    "__docId__": 34,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/builder.js~Measurement",
    "longname": "src/builder.js~Measurement#constructor",
    "access": null,
    "description": null,
    "lineNumber": 247,
    "undocument": true,
    "params": [],
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 35,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "parts",
    "memberof": "src/builder.js~Measurement",
    "longname": "src/builder.js~Measurement#parts",
    "access": null,
    "description": null,
    "lineNumber": 248,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 36,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "name",
    "memberof": "src/builder.js~Measurement",
    "longname": "src/builder.js~Measurement#name",
    "access": null,
    "description": "Sets the measurement name.",
    "lineNumber": 255,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Measurement"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 37,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "policy",
    "memberof": "src/builder.js~Measurement",
    "longname": "src/builder.js~Measurement#policy",
    "access": null,
    "description": "Sets the retention policy name.",
    "lineNumber": 264,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "retentionPolicy",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Measurement"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 38,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "db",
    "memberof": "src/builder.js~Measurement",
    "longname": "src/builder.js~Measurement#db",
    "access": null,
    "description": "Sets the database name.",
    "lineNumber": 273,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "db",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Measurement"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 39,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "toString",
    "memberof": "src/builder.js~Measurement",
    "longname": "src/builder.js~Measurement#toString",
    "access": null,
    "description": "Converts the measurement into its InfluxQL representation.",
    "lineNumber": 282,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if a measurement name is not provided"
      }
    ],
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 40,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "parseMeasurement",
    "memberof": "src/builder.js",
    "longname": "src/builder.js~parseMeasurement",
    "access": null,
    "export": true,
    "importPath": "influx",
    "importStyle": "{parseMeasurement}",
    "description": null,
    "lineNumber": 291,
    "undocument": true,
    "params": [
      {
        "name": "q",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 41,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "parseWhere",
    "memberof": "src/builder.js",
    "longname": "src/builder.js~parseWhere",
    "access": null,
    "export": true,
    "importPath": "influx",
    "importStyle": "{parseWhere}",
    "description": null,
    "lineNumber": 297,
    "undocument": true,
    "params": [
      {
        "name": "q",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 42,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/doc.js",
    "memberof": null,
    "longname": "src/doc.js",
    "access": null,
    "description": null,
    "lineNumber": 144,
    "content": "/**\n * Pool options can be passed into the database to configure the behaviour\n * of the connection pool.\n * @typedef {Object} IPoolOptions\n * @property {Number} [maxRetries=2] Number of times we should retry running\n *     a query before calling back with an error.\n * @property {Number} [requestTimeout=30000] The length of time after which\n *     HTTP requests will error if they do not receive a response.\n * @property {IBackoffStrategy} [backoff] The backoff strategy to use for\n *     unhealthy connections. Defaults to an exponential backoff with an\n *     initial delay of 300ms and a maximum delay of 10 seconds.\n */\n/**\n * A ISingleHostConfig can be provided into `new InfluxDB(config)` when you\n * have a single Influx address to connect to.\n *\n * @public\n * @typedef {Object} ISingleHostConfig\n * @property {String} [username='root'] Username for connecting to the database.\n * @property {String} [password='root'] Password for connecting to the database.\n * @property {String} [database] Default database to operate on. Providing this\n *     will let you omit database names in most operations, and is convenient\n *     if your app is primarily dealing with a single database.\n * @property {String} [host='127.0.0.1'] Influx host to connect to.\n * @property {Number} [port=8060] Influx port to connect to.\n * @property {String} [protocol='http'] Protocol to connect over, either\n *     'http' or 'https'.\n * @property {IPoolOptions} [pool] Options for the connection pool.\n * @property {ISchemaOptions[]} [schema] An optional list of data schema to use.\n *\n * @example\n * import { InfluxDB } from 'influx'; // or const InfluxDB = require('influx').InfluxDB\n *\n * // Connect to a single host with a full set of config details and\n * // a custom schema\n * const client = new InfluxDB({\n *   database: 'my_db',\n *   host: 'localhost',\n *   port: 8086,\n *   username: 'connor',\n *   password: 'pa$$w0rd',\n *   schema: [{\n *     measurement: 'perf',\n *     tags: ['hostname'],\n *     fields: {\n *       memory_usage: FieldType.INTEGER,\n *       cpu_usage: FieldType.FLOAT,\n *       is_online: FieldType.BOOLEAN,\n *     }\n *   }]\n * })\n */\n/**\n * A IClusterConfig can be provided into `new InfluxDB(config)` when you\n * have a multiple Influx nodes to connect to.\n *\n * @typedef {Object} IClusterConfig\n * @property {String} [username='root'] Username for connecting to the database.\n * @property {String} [password='root'] Password for connecting to the database.\n * @property {String} [database] Default database to operate on. Providing this\n *     will let you omit database names in most operations, and is convenient\n *     if your app is primarily dealing with a single database.\n * @property {Array} hosts A list of Influx hosts to connect to.\n * @property {String} [hosts.host='127.0.0.1'] Influx host to connect to.\n * @property {Number} [hosts.port=8060] Influx port to connect to.\n * @property {String} [hosts.protocol='http'] Protocol to connect over, either\n *     'http' or 'https'.\n * @property {IPoolOptions} [pool] Options for the connection pool.\n * @property {ISchemaOptions[]} [schema] An optional list of data schema to use.\n *\n * @example\n * import { InfluxDB } from 'influx'; // or const InfluxDB = require('influx').InfluxDB\n *\n * // Connect to a single host with a full set of config details and\n * // a custom schema\n * const client = new InfluxDB({\n *   database: 'my_db',\n *   username: 'connor',\n *   password: 'pa$$w0rd',\n *   hosts: [\n *     { host: 'db1.example.com' },\n *     { host: 'db2.example.com' },\n *   ]\n *   schema: [{\n *     measurement: 'perf',\n *     tags: ['hostname'],\n *     fields: {\n *       memory_usage: FieldType.INTEGER,\n *       cpu_usage: FieldType.FLOAT,\n *       is_online: FieldType.BOOLEAN,\n *     }\n *   }]\n * })\n */\n/**\n * Schema options can be passed into the `new InfluxDB()` constructor to\n * help define the shape of your data. Each schema config corresponds to\n * a measurement in Influx\n *\n * It's recommended, but not required, that you make use of schema; internally\n * we use them to be smarter about coercing your data, and providing immediate\n * error feedback if you try to write data which doesn't fit in your schema:\n * either if you include tags of fields which are not present in your schema,\n * or you enter the wrong datatype for one of your schema fields.\n *\n * @typedef {Object} ISchemaOptions\n * @property {String} [database] The database where the measurement lives. This\n *     is required if you don't provide a default database in Influx.\n * @property {String} measurement The measurement name in Influx this refers to\n * @property {Object.<String, FieldType>} fields A mapping of fields names to\n *     their data types. It's assumed that this is a comprehensive mapping of\n *     every field you might write.\n * @property {String[]} tags A list of tag names in this measurement. It's\n *     assumed that this is a comprehensive list of every tag you might write.\n *\n * @example\n * {\n *   measurement: 'perf',\n *   tags: ['hostname'],\n *   fields: {\n *     memory_usage: FieldType.INTEGER,\n *     cpu_usage: FieldType.FLOAT,\n *     is_online: FieldType.BOOLEAN,\n *   }\n * }\n */\n/**\n * IResults are returned from the .query method. It marshals the raw Influx\n * results into a more palatable, JavaScript-y structure. All query results\n * are marshalled into a single, flat arrays, and methods are provided to\n * example grouped results as necessary. The `time` column, if included, is\n * converted into a {@link INanoDate}.\n *\n * @interface\n * @example\n * influx.query('select host, cpu, mem from perf').then(results => {\n *   expect(results).to.deep.equal([\n *     { host: 'ares.peet.io', cpu: 0.12, mem: 2435 },\n *     { host: 'ares.peet.io', cpu: 0.10, mem: 2451 },\n *     // ...\n *   ])\n * })\n */\nexport class IResults extends Array {\n    /**\n     * Group looks for and returns the first group in the results\n     * that matches the provided tags.\n     *\n     * If you've used lodash or underscore, we do something quite similar to\n     * their object matching: for every row in the results, if it contains tag\n     * values matching the requested object, we return it.\n     *\n     * @param  {Object.<String, String>} matcher\n     * @return {T[]}\n     * @example\n     * // Matching tags sets in queries:\n     * influx.query('select * from perf group by host').then(results => {\n     *   expect(results.group({ host: 'ares.peet.io'})).to.deep.equal([\n     *     { host: 'ares.peet.io', cpu: 0.12, mem: 2435 },\n     *     { host: 'ares.peet.io', cpu: 0.10, mem: 2451 },\n     *     // ...\n     *   ])\n     *\n     *   expect(results.group({ host: 'box1.example.com'})).to.deep.equal([\n     *     { host: 'box1.example.com', cpu: 0.54, mem: 8420 },\n     *     // ...\n     *   ])\n     * })\n     */\n    group(matcher) { return null; }\n    /**\n     * Returns the data grouped into nested arrays, similarly to how it was\n     * returned from Influx originally.\n     *\n     * @returns {Array<{ name: String, tags: Object.<String, String>, rows: T[] }>}\n     * @example\n     * influx.query('select * from perf group by host').then(results => {\n     *   expect(results.groups()).to.deep.equal([\n     *     {\n     *       name: 'perf',\n     *       tags: { host: 'ares.peet.io' },\n     *       rows: [\n     *         { host: 'ares.peet.io', cpu: 0.12, mem: 2435 },\n     *         { host: 'ares.peet.io', cpu: 0.10, mem: 2451 },\n     *         // ...\n     *       ]\n     *     }\n     *     {\n     *       name: 'perf',\n     *       tags: { host: 'box1.example.com' },\n     *       rows: [\n     *         { host: 'box1.example.com', cpu: 0.54, mem: 8420 },\n     *         // ...\n     *       ]\n     *     }\n     *   ])\n     * })\n     */\n    groups() { return null; }\n}\n/**\n * IPoint is passed to the client's write methods to store a point in InfluxDB.\n *\n * @typedef {Object} IPoint\n * @property {String} measurement Measurement is the Influx measurement name.\n * @property {Object.<String, String>} [tags] Tags is the list of tag\n *     values to insert.\n * @property {Object.<String, *>} [fields] Fields is the list of\n *     field values to insert.\n * @property {Date|string|number} [fields] Timestamp tags this measurement with\n *     a date. This can be a Date object, in which case we'll adjust it to the\n *     desired precision, or a numeric string or number, in which case\n *     it gets passed directly to Influx.\n */\n/**\n * IWriteOptions configure how points are written in the database.\n *\n * @typedef {Object} IWriteOptions\n * @property {TimePrecision} [precision] Precision at which the points are\n *     written, defaults to milliseconds 'ms'. Influx recommends that you use\n *     the coarsest precision possible in order to maximize efficiency.\n * @property {String} [retentionPolicy] The retention policy to insert\n *     the points under, uses the DEFAULT policy if not provided.\n * @property {String} [database] The database to insert the points in, uses the\n *     adapter's default database if not provided.\n */\n/**\n * The IQueryOptions allow you to configure how queries are run against Influx.\n *\n * @typedef {Object} IQueryOptions\n * @property {TimePrecision} [precision] Defines the precision at which\n *     to query points. Defaults to querying in nanosecond precision.\n * @property {String} [retentionPolicy] Retention policy to query from,\n *     defaults to the DEFAULT retention policy.\n * @property {String} [database]  Database under which to query the points.\n *     This is required if a database is not provided in Influx client.\n */\n/**\n * IPingStats is returned from {@link InfluxDB#ping}.\n *\n * @typedef {Object} IPingStats\n * @property {Url} url URL is the host's URL\n * @property {Boolean} online Whether the request was completed successfully.\n * @property {http.ServerResponse} res The raw response from the server, may be\n *     null on a timeout or HTTP error.\n * @property {Number} rtt Total time the server took to respond, in milliseconds\n * @property {String} version Version number the server reports to run\n */\n/**\n * The IBackoffStrategy dictates behaviour to use when hosts in the connection\n * pool start failing. We remove them from the pool for a duration of time\n * specified by the backoff strategy.\n *\n * The strategy itself is immutable, and each method call should return a new\n * strategy without modifying the original one.\n *\n * @interface\n * @example\n * let backoff = new MyBackoffStrategy();\n * console.log(backoff.getDelay()); // => 10\n * backoff = backoff.next();\n * console.log(backoff.getDelay()); // => 20\n * backoff = backoff.reset();\n * console.log(backoff.getDelay()); // => 10\n */\nexport class IBackoffStrategy {\n    /**\n     * getDelay returns the amount of delay of the current backoff.\n     * @return {Number}\n     */\n    getDelay() { return 0; }\n    /**\n     * Next is called when a failure occurs on a host to\n     * return the next backoff amount.\n     * @return {IBackoffStrategy}\n     */\n    next() { return this; }\n    /**\n     * Returns a strategy with a reset backoff counter.\n     * @return {IBackoffStrategy}\n     */\n    reset() { return this; }\n}\n/**\n * An INanoDate is a type of Date that holds a nanosecond-precision unix\n * timestamp. It's the default date type parsed in {@link IResults} and\n * can be created manually using {@link toNanoDate}.\n * @interface\n */\nexport class INanoDate extends Date {\n    /**\n     * Returns the unix nanoseconds timestamp as a string.\n     * @example\n     * const date = toNanoDate('1475985480231035677')\n     * expect(date.getNanoTime()).to.equal('1475985480231035677')\n     */\n    getNanoTime() { return ''; }\n    ;\n    /**\n     * Formats the date as an ISO RFC3339 timestamp with nanosecond precision.\n     * @example\n     * const date = toNanoDate('1475985480231035677')\n     * expect(date.toNanoISOString()).to.equal('2016-10-09T03:58:00.231035677Z')\n     */\n    toNanoISOString() { return ''; }\n    ;\n}\n",
    "importPath": "influx"
  },
  {
    "__docId__": 43,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "IPoolOptions",
    "memberof": "src/doc.js",
    "longname": "src/doc.js~IPoolOptions",
    "access": null,
    "description": "Pool options can be passed into the database to configure the behaviour\nof the connection pool.",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "2",
        "defaultRaw": 2,
        "name": "maxRetries",
        "description": "Number of times we should retry running\n    a query before calling back with an error."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "30000",
        "defaultRaw": 30000,
        "name": "requestTimeout",
        "description": "The length of time after which\n    HTTP requests will error if they do not receive a response."
      },
      {
        "nullable": null,
        "types": [
          "IBackoffStrategy"
        ],
        "spread": false,
        "optional": true,
        "name": "backoff",
        "description": "The backoff strategy to use for\n    unhealthy connections. Defaults to an exponential backoff with an\n    initial delay of 300ms and a maximum delay of 10 seconds."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "IPoolOptions"
    },
    "importPath": "influx"
  },
  {
    "__docId__": 44,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "ISingleHostConfig",
    "memberof": "src/doc.js",
    "longname": "src/doc.js~ISingleHostConfig",
    "access": "public",
    "description": "A ISingleHostConfig can be provided into `new InfluxDB(config)` when you\nhave a single Influx address to connect to.",
    "examples": [
      "import { InfluxDB } from 'influx'; // or const InfluxDB = require('influx').InfluxDB\n\n// Connect to a single host with a full set of config details and\n// a custom schema\nconst client = new InfluxDB({\n  database: 'my_db',\n  host: 'localhost',\n  port: 8086,\n  username: 'connor',\n  password: 'pa$$w0rd',\n  schema: [{\n    measurement: 'perf',\n    tags: ['hostname'],\n    fields: {\n      memory_usage: FieldType.INTEGER,\n      cpu_usage: FieldType.FLOAT,\n      is_online: FieldType.BOOLEAN,\n    }\n  }]\n})"
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'root'",
        "defaultRaw": "'root'",
        "name": "username",
        "description": "Username for connecting to the database."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'root'",
        "defaultRaw": "'root'",
        "name": "password",
        "description": "Password for connecting to the database."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "Default database to operate on. Providing this\n    will let you omit database names in most operations, and is convenient\n    if your app is primarily dealing with a single database."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'127.0.0.1'",
        "defaultRaw": "'127.0.0.1'",
        "name": "host",
        "description": "Influx host to connect to."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "8060",
        "defaultRaw": 8060,
        "name": "port",
        "description": "Influx port to connect to."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'http'",
        "defaultRaw": "'http'",
        "name": "protocol",
        "description": "Protocol to connect over, either\n    'http' or 'https'."
      },
      {
        "nullable": null,
        "types": [
          "IPoolOptions"
        ],
        "spread": false,
        "optional": true,
        "name": "pool",
        "description": "Options for the connection pool."
      },
      {
        "nullable": null,
        "types": [
          "ISchemaOptions[]"
        ],
        "spread": false,
        "optional": true,
        "name": "schema",
        "description": "An optional list of data schema to use."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ISingleHostConfig"
    },
    "importPath": "influx"
  },
  {
    "__docId__": 45,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "IClusterConfig",
    "memberof": "src/doc.js",
    "longname": "src/doc.js~IClusterConfig",
    "access": null,
    "description": "A IClusterConfig can be provided into `new InfluxDB(config)` when you\nhave a multiple Influx nodes to connect to.",
    "examples": [
      "import { InfluxDB } from 'influx'; // or const InfluxDB = require('influx').InfluxDB\n\n// Connect to a single host with a full set of config details and\n// a custom schema\nconst client = new InfluxDB({\n  database: 'my_db',\n  username: 'connor',\n  password: 'pa$$w0rd',\n  hosts: [\n    { host: 'db1.example.com' },\n    { host: 'db2.example.com' },\n  ]\n  schema: [{\n    measurement: 'perf',\n    tags: ['hostname'],\n    fields: {\n      memory_usage: FieldType.INTEGER,\n      cpu_usage: FieldType.FLOAT,\n      is_online: FieldType.BOOLEAN,\n    }\n  }]\n})"
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'root'",
        "defaultRaw": "'root'",
        "name": "username",
        "description": "Username for connecting to the database."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'root'",
        "defaultRaw": "'root'",
        "name": "password",
        "description": "Password for connecting to the database."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "Default database to operate on. Providing this\n    will let you omit database names in most operations, and is convenient\n    if your app is primarily dealing with a single database."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "hosts",
        "description": "A list of Influx hosts to connect to."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'127.0.0.1'",
        "defaultRaw": "'127.0.0.1'",
        "name": "hosts.host",
        "description": "Influx host to connect to."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "8060",
        "defaultRaw": 8060,
        "name": "hosts.port",
        "description": "Influx port to connect to."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'http'",
        "defaultRaw": "'http'",
        "name": "hosts.protocol",
        "description": "Protocol to connect over, either\n    'http' or 'https'."
      },
      {
        "nullable": null,
        "types": [
          "IPoolOptions"
        ],
        "spread": false,
        "optional": true,
        "name": "pool",
        "description": "Options for the connection pool."
      },
      {
        "nullable": null,
        "types": [
          "ISchemaOptions[]"
        ],
        "spread": false,
        "optional": true,
        "name": "schema",
        "description": "An optional list of data schema to use."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "IClusterConfig"
    },
    "importPath": "influx"
  },
  {
    "__docId__": 46,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "ISchemaOptions",
    "memberof": "src/doc.js",
    "longname": "src/doc.js~ISchemaOptions",
    "access": null,
    "description": "Schema options can be passed into the `new InfluxDB()` constructor to\nhelp define the shape of your data. Each schema config corresponds to\na measurement in Influx\n\nIt's recommended, but not required, that you make use of schema; internally\nwe use them to be smarter about coercing your data, and providing immediate\nerror feedback if you try to write data which doesn't fit in your schema:\neither if you include tags of fields which are not present in your schema,\nor you enter the wrong datatype for one of your schema fields.",
    "examples": [
      "{\n  measurement: 'perf',\n  tags: ['hostname'],\n  fields: {\n    memory_usage: FieldType.INTEGER,\n    cpu_usage: FieldType.FLOAT,\n    is_online: FieldType.BOOLEAN,\n  }\n}"
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "The database where the measurement lives. This\n    is required if you don't provide a default database in Influx."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "measurement",
        "description": "The measurement name in Influx this refers to"
      },
      {
        "nullable": null,
        "types": [
          "Object.<String, FieldType>"
        ],
        "spread": false,
        "optional": false,
        "name": "fields",
        "description": "A mapping of fields names to\n    their data types. It's assumed that this is a comprehensive mapping of\n    every field you might write."
      },
      {
        "nullable": null,
        "types": [
          "String[]"
        ],
        "spread": false,
        "optional": false,
        "name": "tags",
        "description": "A list of tag names in this measurement. It's\n    assumed that this is a comprehensive list of every tag you might write."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "ISchemaOptions"
    },
    "importPath": "influx"
  },
  {
    "__docId__": 47,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "IResults",
    "memberof": "src/doc.js",
    "longname": "src/doc.js~IResults",
    "access": null,
    "export": true,
    "importPath": "influx",
    "importStyle": "{IResults}",
    "description": "IResults are returned from the .query method. It marshals the raw Influx\nresults into a more palatable, JavaScript-y structure. All query results\nare marshalled into a single, flat arrays, and methods are provided to\nexample grouped results as necessary. The `time` column, if included, is\nconverted into a {@link INanoDate}.",
    "examples": [
      "influx.query('select host, cpu, mem from perf').then(results => {\n  expect(results).to.deep.equal([\n    { host: 'ares.peet.io', cpu: 0.12, mem: 2435 },\n    { host: 'ares.peet.io', cpu: 0.10, mem: 2451 },\n    // ...\n  ])\n})"
    ],
    "lineNumber": 144,
    "interface": true,
    "extends": [
      "Array"
    ]
  },
  {
    "__docId__": 48,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "group",
    "memberof": "src/doc.js~IResults",
    "longname": "src/doc.js~IResults#group",
    "access": null,
    "description": "Group looks for and returns the first group in the results\nthat matches the provided tags.\n\nIf you've used lodash or underscore, we do something quite similar to\ntheir object matching: for every row in the results, if it contains tag\nvalues matching the requested object, we return it.",
    "examples": [
      "// Matching tags sets in queries:\ninflux.query('select * from perf group by host').then(results => {\n  expect(results.group({ host: 'ares.peet.io'})).to.deep.equal([\n    { host: 'ares.peet.io', cpu: 0.12, mem: 2435 },\n    { host: 'ares.peet.io', cpu: 0.10, mem: 2451 },\n    // ...\n  ])\n\n  expect(results.group({ host: 'box1.example.com'})).to.deep.equal([\n    { host: 'box1.example.com', cpu: 0.54, mem: 8420 },\n    // ...\n  ])\n})"
    ],
    "lineNumber": 170,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object.<String, String>"
        ],
        "spread": false,
        "optional": false,
        "name": "matcher",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "T[]"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 49,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "groups",
    "memberof": "src/doc.js~IResults",
    "longname": "src/doc.js~IResults#groups",
    "access": null,
    "description": "Returns the data grouped into nested arrays, similarly to how it was\nreturned from Influx originally.",
    "examples": [
      "influx.query('select * from perf group by host').then(results => {\n  expect(results.groups()).to.deep.equal([\n    {\n      name: 'perf',\n      tags: { host: 'ares.peet.io' },\n      rows: [\n        { host: 'ares.peet.io', cpu: 0.12, mem: 2435 },\n        { host: 'ares.peet.io', cpu: 0.10, mem: 2451 },\n        // ...\n      ]\n    }\n    {\n      name: 'perf',\n      tags: { host: 'box1.example.com' },\n      rows: [\n        { host: 'box1.example.com', cpu: 0.54, mem: 8420 },\n        // ...\n      ]\n    }\n  ])\n})"
    ],
    "lineNumber": 199,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<{ name: String, tags: Object.<String, String>, rows: T[] }>}"
      }
    ],
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Array<{ name: String, tags: Object.<String, String>, rows: T[] }>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 50,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "IPoint",
    "memberof": "src/doc.js",
    "longname": "src/doc.js~IPoint",
    "access": null,
    "description": "IPoint is passed to the client's write methods to store a point in InfluxDB.",
    "properties": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "measurement",
        "description": "Measurement is the Influx measurement name."
      },
      {
        "nullable": null,
        "types": [
          "Object.<String, String>"
        ],
        "spread": false,
        "optional": true,
        "name": "tags",
        "description": "Tags is the list of tag\n    values to insert."
      },
      {
        "nullable": null,
        "types": [
          "Object.<String, *>"
        ],
        "spread": false,
        "optional": true,
        "name": "fields",
        "description": "Fields is the list of\n    field values to insert."
      },
      {
        "nullable": null,
        "types": [
          "Date",
          "string",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "fields",
        "description": "Timestamp tags this measurement with\n    a date. This can be a Date object, in which case we'll adjust it to the\n    desired precision, or a numeric string or number, in which case\n    it gets passed directly to Influx."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "IPoint"
    },
    "importPath": "influx"
  },
  {
    "__docId__": 51,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "IWriteOptions",
    "memberof": "src/doc.js",
    "longname": "src/doc.js~IWriteOptions",
    "access": null,
    "description": "IWriteOptions configure how points are written in the database.",
    "properties": [
      {
        "nullable": null,
        "types": [
          "TimePrecision"
        ],
        "spread": false,
        "optional": true,
        "name": "precision",
        "description": "Precision at which the points are\n    written, defaults to milliseconds 'ms'. Influx recommends that you use\n    the coarsest precision possible in order to maximize efficiency."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "retentionPolicy",
        "description": "The retention policy to insert\n    the points under, uses the DEFAULT policy if not provided."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "The database to insert the points in, uses the\n    adapter's default database if not provided."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "IWriteOptions"
    },
    "importPath": "influx"
  },
  {
    "__docId__": 52,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "IQueryOptions",
    "memberof": "src/doc.js",
    "longname": "src/doc.js~IQueryOptions",
    "access": null,
    "description": "The IQueryOptions allow you to configure how queries are run against Influx.",
    "properties": [
      {
        "nullable": null,
        "types": [
          "TimePrecision"
        ],
        "spread": false,
        "optional": true,
        "name": "precision",
        "description": "Defines the precision at which\n    to query points. Defaults to querying in nanosecond precision."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "retentionPolicy",
        "description": "Retention policy to query from,\n    defaults to the DEFAULT retention policy."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "Database under which to query the points.\n    This is required if a database is not provided in Influx client."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "IQueryOptions"
    },
    "importPath": "influx"
  },
  {
    "__docId__": 53,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "IPingStats",
    "memberof": "src/doc.js",
    "longname": "src/doc.js~IPingStats",
    "access": null,
    "description": "IPingStats is returned from {@link InfluxDB#ping}.",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Url"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "URL is the host's URL"
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "online",
        "description": "Whether the request was completed successfully."
      },
      {
        "nullable": null,
        "types": [
          "http.ServerResponse"
        ],
        "spread": false,
        "optional": false,
        "name": "res",
        "description": "The raw response from the server, may be\n    null on a timeout or HTTP error."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "rtt",
        "description": "Total time the server took to respond, in milliseconds"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "version",
        "description": "Version number the server reports to run"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "IPingStats"
    },
    "importPath": "influx"
  },
  {
    "__docId__": 54,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "IBackoffStrategy",
    "memberof": "src/doc.js",
    "longname": "src/doc.js~IBackoffStrategy",
    "access": null,
    "export": true,
    "importPath": "influx",
    "importStyle": "{IBackoffStrategy}",
    "description": "The IBackoffStrategy dictates behaviour to use when hosts in the connection\npool start failing. We remove them from the pool for a duration of time\nspecified by the backoff strategy.\n\nThe strategy itself is immutable, and each method call should return a new\nstrategy without modifying the original one.",
    "examples": [
      "let backoff = new MyBackoffStrategy();\nconsole.log(backoff.getDelay()); // => 10\nbackoff = backoff.next();\nconsole.log(backoff.getDelay()); // => 20\nbackoff = backoff.reset();\nconsole.log(backoff.getDelay()); // => 10"
    ],
    "lineNumber": 266,
    "interface": true
  },
  {
    "__docId__": 55,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getDelay",
    "memberof": "src/doc.js~IBackoffStrategy",
    "longname": "src/doc.js~IBackoffStrategy#getDelay",
    "access": null,
    "description": "getDelay returns the amount of delay of the current backoff.",
    "lineNumber": 271,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 56,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "next",
    "memberof": "src/doc.js~IBackoffStrategy",
    "longname": "src/doc.js~IBackoffStrategy#next",
    "access": null,
    "description": "Next is called when a failure occurs on a host to\nreturn the next backoff amount.",
    "lineNumber": 277,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "IBackoffStrategy"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 57,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "reset",
    "memberof": "src/doc.js~IBackoffStrategy",
    "longname": "src/doc.js~IBackoffStrategy#reset",
    "access": null,
    "description": "Returns a strategy with a reset backoff counter.",
    "lineNumber": 282,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "IBackoffStrategy"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 58,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "INanoDate",
    "memberof": "src/doc.js",
    "longname": "src/doc.js~INanoDate",
    "access": null,
    "export": true,
    "importPath": "influx",
    "importStyle": "{INanoDate}",
    "description": "An INanoDate is a type of Date that holds a nanosecond-precision unix\ntimestamp. It's the default date type parsed in {@link IResults} and\ncan be created manually using {@link toNanoDate}.",
    "lineNumber": 290,
    "interface": true,
    "extends": [
      "Date"
    ]
  },
  {
    "__docId__": 59,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getNanoTime",
    "memberof": "src/doc.js~INanoDate",
    "longname": "src/doc.js~INanoDate#getNanoTime",
    "access": null,
    "description": "Returns the unix nanoseconds timestamp as a string.",
    "examples": [
      "const date = toNanoDate('1475985480231035677')\nexpect(date.getNanoTime()).to.equal('1475985480231035677')"
    ],
    "lineNumber": 297,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 60,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "toNanoISOString",
    "memberof": "src/doc.js~INanoDate",
    "longname": "src/doc.js~INanoDate#toNanoISOString",
    "access": null,
    "description": "Formats the date as an ISO RFC3339 timestamp with nanosecond precision.",
    "examples": [
      "const date = toNanoDate('1475985480231035677')\nexpect(date.toNanoISOString()).to.equal('2016-10-09T03:58:00.231035677Z')"
    ],
    "lineNumber": 305,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 61,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/grammar/ds.js",
    "memberof": null,
    "longname": "src/grammar/ds.js",
    "access": null,
    "description": null,
    "lineNumber": 17,
    "content": "/**\n * FieldType is an enumeration of InfluxDB field data types.\n * @typedef {Number} FieldType\n * @example\n * import { FieldType } from 'influx'; // or const FieldType = require('influx').FieldType\n *\n * const schema = {\n *   measurement: 'my_measurement',\n *   fields: {\n *     my_int: FieldType.INTEGER,\n *     my_float: FieldType.FLOAT,\n *     my_string: FieldType.STRING,\n *     my_boolean: FieldType.BOOLEAN,\n *   }\n * }\n */\nexport var FieldType;\n(function (FieldType) {\n    FieldType[FieldType[\"FLOAT\"] = 0] = \"FLOAT\";\n    FieldType[FieldType[\"INTEGER\"] = 1] = \"INTEGER\";\n    FieldType[FieldType[\"STRING\"] = 2] = \"STRING\";\n    FieldType[FieldType[\"BOOLEAN\"] = 3] = \"BOOLEAN\";\n})(FieldType || (FieldType = {}));\nexport function isNumeric(value) {\n    return !Number.isNaN(Number(value));\n}\n/**\n * You can provide Raw values to Influx methods to prevent it from escaping\n * your provided string.\n * @class\n * @example\n * influx.createDatabase(new Influx.Raw('This won\\'t be escaped!'));\n */\nexport class Raw {\n    /**\n     * Wraps a string so that it is not escaped in Influx queries.\n     * @param {String} value\n     * @example\n     * influx.createDatabase(new Influx.Raw('This won\\'t be escaped!'));\n     */\n    constructor(value) {\n        this.value = value;\n    }\n    /**\n     * Returns the wrapped string.\n     * @return {String}\n     */\n    getValue() {\n        return this.value;\n    }\n}\n",
    "importPath": "influx"
  },
  {
    "__docId__": 62,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "FieldType",
    "memberof": "src/grammar/ds.js",
    "longname": "src/grammar/ds.js~FieldType",
    "access": null,
    "description": "FieldType is an enumeration of InfluxDB field data types.",
    "examples": [
      "import { FieldType } from 'influx'; // or const FieldType = require('influx').FieldType\n\nconst schema = {\n  measurement: 'my_measurement',\n  fields: {\n    my_int: FieldType.INTEGER,\n    my_float: FieldType.FLOAT,\n    my_string: FieldType.STRING,\n    my_boolean: FieldType.BOOLEAN,\n  }\n}"
    ],
    "lineNumber": 17,
    "type": {
      "types": [
        "Number"
      ],
      "optional": false,
      "name": "FieldType"
    },
    "importPath": "influx"
  },
  {
    "__docId__": 63,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "isNumeric",
    "memberof": "src/grammar/ds.js",
    "longname": "src/grammar/ds.js~isNumeric",
    "access": null,
    "export": true,
    "importPath": "influx",
    "importStyle": "{isNumeric}",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 64,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "Raw",
    "memberof": "src/grammar/ds.js",
    "longname": "src/grammar/ds.js~Raw",
    "access": null,
    "export": true,
    "importPath": "influx",
    "importStyle": "{Raw}",
    "description": "You can provide Raw values to Influx methods to prevent it from escaping\nyour provided string.",
    "examples": [
      "influx.createDatabase(new Influx.Raw('This won\\'t be escaped!'));"
    ],
    "lineNumber": 34,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 65,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/grammar/ds.js~Raw",
    "longname": "src/grammar/ds.js~Raw#constructor",
    "access": null,
    "description": "Wraps a string so that it is not escaped in Influx queries.",
    "examples": [
      "influx.createDatabase(new Influx.Raw('This won\\'t be escaped!'));"
    ],
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 66,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "value",
    "memberof": "src/grammar/ds.js~Raw",
    "longname": "src/grammar/ds.js~Raw#value",
    "access": null,
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 67,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getValue",
    "memberof": "src/grammar/ds.js~Raw",
    "longname": "src/grammar/ds.js~Raw#getValue",
    "access": null,
    "description": "Returns the wrapped string.",
    "lineNumber": 48,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 68,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/grammar/escape.js",
    "memberof": null,
    "longname": "src/grammar/escape.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import { Raw } from './ds';\nconst reEscape = /[-|\\\\{()[\\]^$+*?.]/g;\n/**\n * The Escaper escapes the special characters in the provided list\n * with backslashes. Much of the code here is inspired by that in the\n * sqlstring packet found here: https://github.com/mysqljs/sqlstring\n *\n * Instances of the Escaper are derived from the documentation of escape\n * sequences found here: https://aka.ms/co1m4k\n *\n * sqlstring is made available under the following license:\n *\n *   Copyright (c) 2012 Felix Geisendörfer (felix@debuggable.com) and contributors\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy\n *   of this software and associated documentation files (the \"Software\"), to deal\n *   in the Software without restriction, including without limitation the rights\n *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *   copies of the Software, and to permit persons to whom the Software is\n *   furnished to do so, subject to the following conditions:\n *\n *   The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n *\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *   THE SOFTWARE.\n *\n */\nclass Escaper {\n    constructor(chars, wrap = '', escaper = '\\\\') {\n        this.wrap = wrap;\n        this.escaper = escaper;\n        const patterns = chars.join('').replace(reEscape, '\\\\$&');\n        this.re = new RegExp('[' + patterns + ']', 'g');\n    }\n    /**\n     * Escape replaces occurrences of special characters within the target\n     * string with the necessary escape codes.\n     */\n    escape(val) {\n        if (val instanceof Raw) {\n            return val.getValue();\n        }\n        let chunkIndex = this.re.lastIndex = 0;\n        let escapedVal = '';\n        let match = this.re.exec(val);\n        while (match) {\n            escapedVal += val.slice(chunkIndex, match.index) + this.escaper + match[0];\n            chunkIndex = this.re.lastIndex;\n            match = this.re.exec(val);\n        }\n        if (chunkIndex === 0) {\n            return this.wrap + val + this.wrap;\n        }\n        if (chunkIndex < val.length) {\n            return this.wrap + escapedVal + val.slice(chunkIndex) + this.wrap;\n        }\n        return this.wrap + escapedVal + this.wrap;\n    }\n}\nconst bindEsc = (e) => e.escape.bind(e);\n/**\n * tagEscaper escapes tag keys, tag values, and field keys.\n * @type {Object}\n * @property {function(s: string): string } quoted Escapes and wraps quoted\n *     values, such as database names.\n * @property {function(s: string): string } stringLit Escapes and\n *     wraps string literals.\n * @property {function(s: string): string } measurement Escapes measurement\n *     names on the line protocol.\n * @property {function(s: string): string } tag Escapes tag keys, take values,\n *     and field keys on the line protocol.\n *\n * @example\n * console.log(escape.quoted('my_\"db')); // => \"my_\\\"db\"\n * console.log(escape.stringLit('hello\\'world')); // => 'hello\\'world'\n *\n * console.log(escape.measurement('my measurement')); // => my\\ measurement\n * console.log(escape.tag('my tag=')); // => my\\ tag\\=\n */\nexport const escape = {\n    /**\n     * measurement escapes measurement names.\n     */\n    measurement: bindEsc(new Escaper([',', ' '])),\n    /**\n     * quoted escapes quoted values, such as database names.\n     */\n    quoted: bindEsc(new Escaper(['\"'], '\"')),\n    /**\n     * stringLitEscaper escapes single quotes in string literals.\n     */\n    stringLit: bindEsc(new Escaper(['\\''], '\\'')),\n    /**\n     * tagEscaper escapes tag keys, tag values, and field keys.\n     */\n    tag: bindEsc(new Escaper([',', '=', ' '])),\n};\n",
    "importPath": "influx"
  },
  {
    "__docId__": 69,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "reEscape",
    "memberof": "src/grammar/escape.js",
    "longname": "src/grammar/escape.js~reEscape",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "type": {
      "types": [
        "object"
      ]
    }
  },
  {
    "__docId__": 70,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "Escaper",
    "memberof": "src/grammar/escape.js",
    "longname": "src/grammar/escape.js~Escaper",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": "The Escaper escapes the special characters in the provided list\nwith backslashes. Much of the code here is inspired by that in the\nsqlstring packet found here: https://github.com/mysqljs/sqlstring\n\nInstances of the Escaper are derived from the documentation of escape\nsequences found here: https://aka.ms/co1m4k\n\nsqlstring is made available under the following license:\n\n  Copyright (c) 2012 Felix Geisendörfer (felix@debuggable.com) and contributors\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.",
    "lineNumber": 34,
    "interface": false
  },
  {
    "__docId__": 71,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/grammar/escape.js~Escaper",
    "longname": "src/grammar/escape.js~Escaper#constructor",
    "access": null,
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "params": [
      {
        "name": "chars",
        "types": [
          "*"
        ]
      },
      {
        "name": "wrap",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "",
        "defaultValue": ""
      },
      {
        "name": "escaper",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "\\",
        "defaultValue": "\\"
      }
    ],
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 72,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "wrap",
    "memberof": "src/grammar/escape.js~Escaper",
    "longname": "src/grammar/escape.js~Escaper#wrap",
    "access": null,
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 73,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "escaper",
    "memberof": "src/grammar/escape.js~Escaper",
    "longname": "src/grammar/escape.js~Escaper#escaper",
    "access": null,
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 74,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "re",
    "memberof": "src/grammar/escape.js~Escaper",
    "longname": "src/grammar/escape.js~Escaper#re",
    "access": null,
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 75,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "escape",
    "memberof": "src/grammar/escape.js~Escaper",
    "longname": "src/grammar/escape.js~Escaper#escape",
    "access": null,
    "description": "Escape replaces occurrences of special characters within the target\nstring with the necessary escape codes.",
    "lineNumber": 45,
    "params": [
      {
        "name": "val",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 76,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "bindEsc",
    "memberof": "src/grammar/escape.js",
    "longname": "src/grammar/escape.js~bindEsc",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 77,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "escape",
    "memberof": "src/grammar/escape.js",
    "longname": "src/grammar/escape.js~escape",
    "access": null,
    "export": true,
    "importPath": "influx",
    "importStyle": "{escape}",
    "description": "tagEscaper escapes tag keys, tag values, and field keys.",
    "examples": [
      "console.log(escape.quoted('my_\"db')); // => \"my_\\\"db\"\nconsole.log(escape.stringLit('hello\\'world')); // => 'hello\\'world'\n\nconsole.log(escape.measurement('my measurement')); // => my\\ measurement\nconsole.log(escape.tag('my tag=')); // => my\\ tag\\="
    ],
    "lineNumber": 86,
    "properties": [
      {
        "nullable": null,
        "types": [
          "function(s: string): string "
        ],
        "spread": false,
        "optional": false,
        "name": "quoted",
        "description": "Escapes and wraps quoted\n    values, such as database names."
      },
      {
        "nullable": null,
        "types": [
          "function(s: string): string "
        ],
        "spread": false,
        "optional": false,
        "name": "stringLit",
        "description": "Escapes and\n    wraps string literals."
      },
      {
        "nullable": null,
        "types": [
          "function(s: string): string "
        ],
        "spread": false,
        "optional": false,
        "name": "measurement",
        "description": "Escapes measurement\n    names on the line protocol."
      },
      {
        "nullable": null,
        "types": [
          "function(s: string): string "
        ],
        "spread": false,
        "optional": false,
        "name": "tag",
        "description": "Escapes tag keys, take values,\n    and field keys on the line protocol."
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 78,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/grammar/index.js",
    "memberof": null,
    "longname": "src/grammar/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "export * from './escape';\nexport * from './ds';\nexport * from './times';\n",
    "importPath": "influx"
  },
  {
    "__docId__": 79,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/grammar/times.js",
    "memberof": null,
    "longname": "src/grammar/times.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import { isNumeric } from './ds';\n/**\n * Just a quick overview of what's going on in this file. It's a bit of a mess.\n * Influx uses three time formats:\n *  - ISO times with nanoseconds when querying where an epoch is not provided\n *  - Unix timestamps when querying with an epoch (specifying the precision\n *    in the given time unit)\n *  - Its own time format for time literals.\n *\n * To complicate matters, Influx operates on nanosecond precisions\n * by default, but we can't represent nanosecond timestamps in\n * JavaScript numbers as they're 64 bit uints.\n *\n * As a result we have several utilities to convert between these different\n * formats. When precision is required, we represent nanosecond timestamps\n * as strings and wrap default dates in the INanoDate interface which\n * lets the consumer read and write these more precise timestamps.\n *\n * Representing the timestamps as strings is definitely not a pure way to go\n * about it, but importing an arbitrary-precision integer library adds\n * bloat and is a massive hit to throughput. The operations we do do\n * are pretty trivial, so we stick with manipulating strings\n * and make sure to wash our hands when we're done.\n *\n * Vocabulary:\n *  Unix timestamp   = 'timestamp', abbreviated as 'time'\n *  ISO timestamp    = 'ISO time', abbreviated as 'ISO'\n *  Influx timestamp = 'Influx time', abbreviated as 'Influx'\n */\nfunction leftPad(str, length, pad = '0') {\n    if (typeof str === 'number') {\n        str = String(str);\n    }\n    while (str.length < length) {\n        str = pad + str;\n    }\n    return str;\n}\nfunction rightPad(str, length, pad = '0') {\n    if (typeof str === 'number') {\n        str = String(str);\n    }\n    while (str.length < length) {\n        str += pad;\n    }\n    return str;\n}\n/**\n * Precision is a map of available Influx time precisions.\n * @type {Object.<String, String>}\n * @example\n * console.log(Precision.Hours); // => 'h'\n * console.log(Precision.Minutes); // => 'm'\n * console.log(Precision.Seconds); // => 's'\n * console.log(Precision.Milliseconds); // => 'ms'\n * console.log(Precision.Microseconds); // => 'u'\n * console.log(Precision.Nanoseconds); // => 'ns'\n */\nexport const Precision = Object.freeze({\n    Hours: 'h',\n    Microseconds: 'u',\n    Milliseconds: 'ms',\n    Minutes: 'm',\n    Nanoseconds: 'n',\n    Seconds: 's',\n});\nclass MillisecondDateManipulator {\n    format(date) {\n        return '\"' + leftPad(date.getUTCFullYear(), 2)\n            + '-' + leftPad(date.getUTCMonth() + 1, 2)\n            + '-' + leftPad(date.getUTCDate(), 2)\n            + ' ' + leftPad(date.getUTCHours(), 2)\n            + ':' + leftPad(date.getUTCMinutes(), 2)\n            + ':' + leftPad(date.getUTCSeconds(), 2)\n            + '.' + leftPad(date.getUTCMilliseconds(), 3) + '\"';\n    }\n    toTime(date, precision) {\n        let ms = date.getTime();\n        switch (precision) {\n            case 'n':\n                ms *= 1000;\n            case 'u':\n                ms *= 1000;\n            case 'ms':\n                return String(ms);\n            case 'h':\n                ms /= 60;\n            case 'm':\n                ms /= 60;\n            case 's':\n                ms /= 1000;\n                return String(Math.floor(ms));\n            default:\n                throw new Error(`Unknown precision '${precision}'!`);\n        }\n    }\n    isoToDate(timestamp) {\n        return new Date(timestamp);\n    }\n    timetoDate(timestamp, precision) {\n        switch (precision) {\n            case 'n':\n                timestamp /= 1000;\n            case 'u':\n                timestamp /= 1000;\n            case 'ms':\n                return new Date(timestamp);\n            case 'h':\n                timestamp *= 60;\n            case 'm':\n                timestamp *= 60;\n            case 's':\n                timestamp *= 1000;\n                return new Date(timestamp);\n            default:\n                throw new Error(`Unknown precision '${precision}'!`);\n        }\n    }\n}\nconst nsPer = {\n    ms: Math.pow(10, 6),\n    s: Math.pow(10, 9),\n};\nfunction nanoIsoToTime(iso) {\n    const [secondsStr, decimalStr] = iso.split('.');\n    const seconds = Math.floor(new Date(secondsStr + 'Z').getTime() / 1000);\n    const decimal = rightPad(decimalStr.slice(0, -1), 9);\n    return `${seconds}${decimal}`;\n}\nconst nanoDateMethods = {\n    getNanoTimeFromISO() {\n        if (!this._cachedNanoISO) {\n            this._cachedNanoTime = nanoIsoToTime(this._nanoISO);\n        }\n        return this._cachedNanoTime;\n    },\n    toNanoISOStringFromISO() {\n        if (!this._cachedNanoISO) {\n            this._cachedNanoTime = nanoIsoToTime(this._nanoISO);\n        }\n        const base = this.toISOString().slice(0, -4); // slice of `123Z` milliseconds\n        return `${base}${this._cachedNanoTime.slice(-9)}Z`;\n    },\n    getNanoTimeFromStamp() {\n        return this._nanoTime;\n    },\n    toNanoISOStringFromStamp() {\n        const base = this.toISOString().slice(0, -4); // slice of `123Z` milliseconds\n        return `${base}${this._nanoTime.slice(-9)}Z`;\n    },\n};\n/**\n * Covers a nanoseconds unix timestamp to a INanoDate for node-influx. The\n * timestamp is provided as a string to prevent precision loss.\n *\n * Please see [A Moment for Times](https://node-influx.github.io/manual/\n * usage.html#a-moment-for-times) for a more complete and eloquent explanation\n * of time handling in this module.\n *\n * @param {String} timestamp\n * @returns {INanoDate}\n * @example\n * const date = toNanoDate('1475985480231035600')\n *\n * // You can use the returned Date as a normal date:\n * expect(date.getTime()).to.equal(1475985480231);\n *\n * // We decorate it with two additional methods to read\n * // nanosecond-precision results:\n * expect(date.getNanoTime()).to.equal('1475985480231035600');\n * expect(date.toNanoISOString()).to.equal('2016-10-09T03:58:00.231035600Z');\n */\nexport function toNanoDate(timestamp) {\n    const date = new Date(Math.floor(Number(timestamp) / nsPer.ms));\n    date._nanoTime = timestamp;\n    date.getNanoTime = nanoDateMethods.getNanoTimeFromStamp;\n    date.toNanoISOString = nanoDateMethods.toNanoISOStringFromStamp;\n    return date;\n}\nfunction asNanoDate(date) {\n    const d = date;\n    if (d.getNanoTime) {\n        return d;\n    }\n    return undefined;\n}\nclass NanosecondsDateManipulator {\n    format(date) {\n        return '\"' + leftPad(date.getUTCFullYear(), 2)\n            + '-' + leftPad(date.getUTCMonth() + 1, 2)\n            + '-' + leftPad(date.getUTCDate(), 2)\n            + ' ' + leftPad(date.getUTCHours(), 2)\n            + ':' + leftPad(date.getUTCMinutes(), 2)\n            + ':' + leftPad(date.getUTCSeconds(), 2)\n            + '.' + date.getNanoTime().slice(-9) + '\"';\n    }\n    toTime(date, precision) {\n        let ms = date.getTime();\n        switch (precision) {\n            case 'u':\n                return date.getNanoTime().slice(0, -3);\n            case 'n':\n                return date.getNanoTime();\n            case 'h':\n                ms /= 60;\n            case 'm':\n                ms /= 60;\n            case 's':\n                ms /= 1000;\n            case 'ms':\n                return String(Math.floor(ms));\n            default:\n                throw new Error(`Unknown precision '${precision}'!`);\n        }\n    }\n    isoToDate(timestamp) {\n        const date = new Date(timestamp);\n        date._nanoISO = timestamp;\n        date.getNanoTime = nanoDateMethods.getNanoTimeFromISO;\n        date.toNanoISOString = nanoDateMethods.toNanoISOStringFromISO;\n        return date;\n    }\n    timetoDate(timestamp, precision) {\n        switch (precision) {\n            case 'h':\n                timestamp *= 60;\n            case 'm':\n                timestamp *= 60;\n            case 's':\n                timestamp *= 1000;\n            case 'ms':\n                timestamp *= 1000;\n            case 'u':\n                timestamp *= 1000;\n            case 'n':\n                const date = new Date(timestamp / nsPer.ms);\n                date._nanoTime = String(timestamp);\n                date.getNanoTime = nanoDateMethods.getNanoTimeFromStamp;\n                date.toNanoISOString = nanoDateMethods.toNanoISOStringFromStamp;\n                return date;\n            default:\n                throw new Error(`Unknown precision '${precision}'!`);\n        }\n    }\n}\nconst milliManipulator = new MillisecondDateManipulator();\nconst nanoManipulator = new NanosecondsDateManipulator();\n/**\n * formatDate converts the Date instance to Influx's date query format.\n * @private\n */\nexport function formatDate(date) {\n    const nano = asNanoDate(date);\n    if (nano) {\n        return nanoManipulator.format(nano);\n    }\n    else {\n        return milliManipulator.format(date);\n    }\n}\n/**\n * Converts a Date instance to a timestamp with the specified time precision.\n * @private\n */\nexport function dateToTime(date, precision) {\n    const nano = asNanoDate(date);\n    if (nano) {\n        return nanoManipulator.toTime(nano, precision);\n    }\n    else {\n        return milliManipulator.toTime(date, precision);\n    }\n}\n/**\n * Converts an ISO-formatted data or unix timestamp to a Date instance. If\n * the precision is finer than 'ms' the returned value will be a INanoDate.\n * @private\n */\nexport function isoOrTimeToDate(stamp, precision = 'n') {\n    if (typeof stamp === 'string') {\n        return nanoManipulator.isoToDate(stamp);\n    }\n    else {\n        return nanoManipulator.timetoDate(stamp, precision);\n    }\n}\n/**\n * Converts a timestamp to a string with the correct precision. Assumes\n * that raw number and string instances are already in the correct precision.\n * @private\n */\nexport function castTimestamp(timestamp, precision) {\n    if (typeof timestamp === 'string') {\n        if (!isNumeric(timestamp)) {\n            throw new Error(`Expected numeric value for, timestamp, but got '${timestamp}'!`);\n        }\n        return timestamp;\n    }\n    if (typeof timestamp === 'number') {\n        return String(timestamp);\n    }\n    return dateToTime(timestamp, precision);\n}\n",
    "importPath": "influx"
  },
  {
    "__docId__": 80,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "leftPad",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~leftPad",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": "Just a quick overview of what's going on in this file. It's a bit of a mess.\nInflux uses three time formats:\n - ISO times with nanoseconds when querying where an epoch is not provided\n - Unix timestamps when querying with an epoch (specifying the precision\n   in the given time unit)\n - Its own time format for time literals.\n\nTo complicate matters, Influx operates on nanosecond precisions\nby default, but we can't represent nanosecond timestamps in\nJavaScript numbers as they're 64 bit uints.\n\nAs a result we have several utilities to convert between these different\nformats. When precision is required, we represent nanosecond timestamps\nas strings and wrap default dates in the INanoDate interface which\nlets the consumer read and write these more precise timestamps.\n\nRepresenting the timestamps as strings is definitely not a pure way to go\nabout it, but importing an arbitrary-precision integer library adds\nbloat and is a massive hit to throughput. The operations we do do\nare pretty trivial, so we stick with manipulating strings\nand make sure to wash our hands when we're done.\n\nVocabulary:\n Unix timestamp   = 'timestamp', abbreviated as 'time'\n ISO timestamp    = 'ISO time', abbreviated as 'ISO'\n Influx timestamp = 'Influx time', abbreviated as 'Influx'",
    "lineNumber": 30,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      },
      {
        "name": "length",
        "types": [
          "*"
        ]
      },
      {
        "name": "pad",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "0",
        "defaultValue": "0"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 81,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "rightPad",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~rightPad",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      },
      {
        "name": "length",
        "types": [
          "*"
        ]
      },
      {
        "name": "pad",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "0",
        "defaultValue": "0"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 82,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "Precision",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~Precision",
    "access": null,
    "export": true,
    "importPath": "influx",
    "importStyle": "{Precision}",
    "description": "Precision is a map of available Influx time precisions.",
    "examples": [
      "console.log(Precision.Hours); // => 'h'\nconsole.log(Precision.Minutes); // => 'm'\nconsole.log(Precision.Seconds); // => 's'\nconsole.log(Precision.Milliseconds); // => 'ms'\nconsole.log(Precision.Microseconds); // => 'u'\nconsole.log(Precision.Nanoseconds); // => 'ns'"
    ],
    "lineNumber": 59,
    "type": {
      "nullable": null,
      "types": [
        "Object.<String, String>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 83,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "MillisecondDateManipulator",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~MillisecondDateManipulator",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": null,
    "lineNumber": 67,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 84,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "format",
    "memberof": "src/grammar/times.js~MillisecondDateManipulator",
    "longname": "src/grammar/times.js~MillisecondDateManipulator#format",
    "access": null,
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 85,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "toTime",
    "memberof": "src/grammar/times.js~MillisecondDateManipulator",
    "longname": "src/grammar/times.js~MillisecondDateManipulator#toTime",
    "access": null,
    "description": null,
    "lineNumber": 77,
    "undocument": true,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 86,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "isoToDate",
    "memberof": "src/grammar/times.js~MillisecondDateManipulator",
    "longname": "src/grammar/times.js~MillisecondDateManipulator#isoToDate",
    "access": null,
    "description": null,
    "lineNumber": 97,
    "undocument": true,
    "params": [
      {
        "name": "timestamp",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 87,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "timetoDate",
    "memberof": "src/grammar/times.js~MillisecondDateManipulator",
    "longname": "src/grammar/times.js~MillisecondDateManipulator#timetoDate",
    "access": null,
    "description": null,
    "lineNumber": 100,
    "undocument": true,
    "params": [
      {
        "name": "timestamp",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 88,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "nsPer",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~nsPer",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": null,
    "lineNumber": 120,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 89,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "nanoIsoToTime",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~nanoIsoToTime",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": null,
    "lineNumber": 124,
    "undocument": true,
    "params": [
      {
        "name": "iso",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 90,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "nanoDateMethods",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~nanoDateMethods",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": null,
    "lineNumber": 130,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 91,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "toNanoDate",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~toNanoDate",
    "access": null,
    "export": true,
    "importPath": "influx",
    "importStyle": "{toNanoDate}",
    "description": "Covers a nanoseconds unix timestamp to a INanoDate for node-influx. The\ntimestamp is provided as a string to prevent precision loss.\n\nPlease see [A Moment for Times](https://node-influx.github.io/manual/\nusage.html#a-moment-for-times) for a more complete and eloquent explanation\nof time handling in this module.",
    "examples": [
      "const date = toNanoDate('1475985480231035600')\n\n// You can use the returned Date as a normal date:\nexpect(date.getTime()).to.equal(1475985480231);\n\n// We decorate it with two additional methods to read\n// nanosecond-precision results:\nexpect(date.getNanoTime()).to.equal('1475985480231035600');\nexpect(date.toNanoISOString()).to.equal('2016-10-09T03:58:00.231035600Z');"
    ],
    "lineNumber": 173,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{INanoDate}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "timestamp",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "INanoDate"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 92,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "asNanoDate",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~asNanoDate",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": null,
    "lineNumber": 180,
    "undocument": true,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 93,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "NanosecondsDateManipulator",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~NanosecondsDateManipulator",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": null,
    "lineNumber": 187,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 94,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "format",
    "memberof": "src/grammar/times.js~NanosecondsDateManipulator",
    "longname": "src/grammar/times.js~NanosecondsDateManipulator#format",
    "access": null,
    "description": null,
    "lineNumber": 188,
    "undocument": true,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 95,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "toTime",
    "memberof": "src/grammar/times.js~NanosecondsDateManipulator",
    "longname": "src/grammar/times.js~NanosecondsDateManipulator#toTime",
    "access": null,
    "description": null,
    "lineNumber": 197,
    "undocument": true,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 96,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "isoToDate",
    "memberof": "src/grammar/times.js~NanosecondsDateManipulator",
    "longname": "src/grammar/times.js~NanosecondsDateManipulator#isoToDate",
    "access": null,
    "description": null,
    "lineNumber": 216,
    "undocument": true,
    "params": [
      {
        "name": "timestamp",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 97,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "timetoDate",
    "memberof": "src/grammar/times.js~NanosecondsDateManipulator",
    "longname": "src/grammar/times.js~NanosecondsDateManipulator#timetoDate",
    "access": null,
    "description": null,
    "lineNumber": 223,
    "undocument": true,
    "params": [
      {
        "name": "timestamp",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 98,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "milliManipulator",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~milliManipulator",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": null,
    "lineNumber": 246,
    "undocument": true,
    "type": {
      "types": [
        "MillisecondDateManipulator"
      ]
    }
  },
  {
    "__docId__": 99,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "nanoManipulator",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~nanoManipulator",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": null,
    "lineNumber": 247,
    "undocument": true,
    "type": {
      "types": [
        "NanosecondsDateManipulator"
      ]
    }
  },
  {
    "__docId__": 100,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "formatDate",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~formatDate",
    "access": "private",
    "export": true,
    "importPath": "influx",
    "importStyle": "{formatDate}",
    "description": "formatDate converts the Date instance to Influx's date query format.",
    "lineNumber": 252,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 101,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "dateToTime",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~dateToTime",
    "access": "private",
    "export": true,
    "importPath": "influx",
    "importStyle": "{dateToTime}",
    "description": "Converts a Date instance to a timestamp with the specified time precision.",
    "lineNumber": 265,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 102,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "isoOrTimeToDate",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~isoOrTimeToDate",
    "access": "private",
    "export": true,
    "importPath": "influx",
    "importStyle": "{isoOrTimeToDate}",
    "description": "Converts an ISO-formatted data or unix timestamp to a Date instance. If\nthe precision is finer than 'ms' the returned value will be a INanoDate.",
    "lineNumber": 279,
    "params": [
      {
        "name": "stamp",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "n",
        "defaultValue": "n"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 103,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "castTimestamp",
    "memberof": "src/grammar/times.js",
    "longname": "src/grammar/times.js~castTimestamp",
    "access": "private",
    "export": true,
    "importPath": "influx",
    "importStyle": "{castTimestamp}",
    "description": "Converts a timestamp to a string with the correct precision. Assumes\nthat raw number and string instances are already in the correct precision.",
    "lineNumber": 292,
    "params": [
      {
        "name": "timestamp",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 104,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/host.js",
    "memberof": null,
    "longname": "src/host.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import * as urlModule from 'url';\nexport class Host {\n    /**\n     * Creates a new Host instance.\n     * @param {String} url\n     * @param {IBackoffStrategy} backoff\n     */\n    constructor(url, backoff) {\n        this.backoff = backoff;\n        this.url = urlModule.parse(url);\n    }\n    /**\n     * Marks a failure on the host and returns the length of time it\n     * should be removed from the pool\n     * @return {Number} removal time in milliseconds\n     */\n    fail() {\n        const value = this.backoff.getDelay();\n        this.backoff = this.backoff.next();\n        return value;\n    }\n    /**\n     * Should be called when a successful operation is run against the host.\n     * It resets the host's backoff strategy.\n     */\n    success() {\n        this.backoff = this.backoff.reset();\n    }\n}\n",
    "importPath": "influx"
  },
  {
    "__docId__": 105,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "Host",
    "memberof": "src/host.js",
    "longname": "src/host.js~Host",
    "access": null,
    "export": true,
    "importPath": "influx",
    "importStyle": "{Host}",
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 106,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/host.js~Host",
    "longname": "src/host.js~Host#constructor",
    "access": null,
    "description": "Creates a new Host instance.",
    "lineNumber": 8,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IBackoffStrategy"
        ],
        "spread": false,
        "optional": false,
        "name": "backoff",
        "description": ""
      }
    ],
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 107,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "backoff",
    "memberof": "src/host.js~Host",
    "longname": "src/host.js~Host#backoff",
    "access": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 108,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "url",
    "memberof": "src/host.js~Host",
    "longname": "src/host.js~Host#url",
    "access": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 109,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "fail",
    "memberof": "src/host.js~Host",
    "longname": "src/host.js~Host#fail",
    "access": null,
    "description": "Marks a failure on the host and returns the length of time it\nshould be removed from the pool",
    "lineNumber": 17,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": "removal time in milliseconds"
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 110,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "backoff",
    "memberof": "src/host.js~Host",
    "longname": "src/host.js~Host#backoff",
    "access": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 111,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "success",
    "memberof": "src/host.js~Host",
    "longname": "src/host.js~Host#success",
    "access": null,
    "description": "Should be called when a successful operation is run against the host.\nIt resets the host's backoff strategy.",
    "lineNumber": 26,
    "params": [],
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 112,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "backoff",
    "memberof": "src/host.js~Host",
    "longname": "src/host.js~Host#backoff",
    "access": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 113,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/index.js",
    "memberof": null,
    "longname": "src/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import { Pool } from './pool';\nimport { assertNoErrors, parse, parseSingle } from './results';\nimport { coerceBadly, Schema } from './schema';\nimport * as b from './builder';\nimport * as grammar from './grammar';\nimport * as url from 'url';\nconst defaultHost = Object.freeze({\n    host: '127.0.0.1',\n    port: 8086,\n    protocol: 'http',\n});\nconst defaultOptions = Object.freeze({\n    database: null,\n    hosts: [],\n    password: 'root',\n    schema: [],\n    username: 'root',\n});\nexport * from './builder';\nexport { FieldType, Precision, Raw, escape, toNanoDate } from './grammar';\nexport { ResultError } from './results';\n/**\n * Parses the URL out into into a IClusterConfig object\n */\nfunction parseOptionsUrl(addr) {\n    const parsed = url.parse(addr);\n    const options = {\n        host: parsed.hostname,\n        port: Number(parsed.port),\n        protocol: parsed.protocol.slice(0, -1),\n    };\n    if (parsed.auth) {\n        [options.username, options.password] = parsed.auth.split(':');\n    }\n    if (parsed.pathname.length > 1) {\n        options.database = parsed.pathname.slice(1);\n    }\n    return options;\n}\n/**\n * Works similarly to Object.assign, but only overwrites\n * properties that resolve to undefined.\n */\nfunction defaults(target, ...srcs) {\n    srcs.forEach(src => {\n        Object.keys(src).forEach(key => {\n            if (target[key] === undefined) {\n                target[key] = src[key];\n            }\n        });\n    });\n    return target;\n}\n/**\n * InfluxDB is the public interface to run queries against the your database.\n * This is a 'driver-level' module, not a a full-fleged ORM or ODM; you run\n * queries directly by calling methods on this class.\n *\n * Please check out some of [the tutorials](https://node-influx.github.io/manual/tutorial.html)\n * if you want help getting started!\n *\n * @example\n * const Influx = require('influx');\n * const influx = new Influx.InfluxDB({\n *  host: 'localhost',\n *  database: 'express_response_db',\n *  schema: [\n *    {\n *      measurement: 'response_times',\n *      fields: {\n *        path: Influx.FieldType.STRING,\n *        duration: Influx.FieldType.INTEGER\n *      },\n *      tags: [\n *        'host'\n *      ]\n *    }\n *  ]\n * })\n *\n * influx.writePoints([\n *   {\n *     measurement: 'response_times',\n *     tags: { host: os.hostname() },\n *     fields: { duration, path: req.path },\n *   }\n * ]).then(() => {\n *   return influx.query(`\n *     select * from response_times\n *     where host = ${Influx.escape.stringLit(os.hostname())}\n *     order by time desc\n *     limit 10\n *   `)\n * }).then(rows => {\n *   rows.forEach(row => console.log(`A request to ${row.path} took ${row.duration}ms`))\n * })\n */\nexport class InfluxDB {\n    /**\n     * Connect to a single InfluxDB instance by specifying\n     * a set of connection options.\n     * @param {IClusterConfig|ISingleHostConfig|string} [options='http://root:root@127.0.0.1:8086']\n     *\n     * @example\n     * const Influx = require('influx')\n     *\n     * // Connect to a single host with a DSN:\n     * const influx = new Influx.InfluxDB('http://user:password@host:8086/database')\n     *\n     * @example\n     * const Influx = require('influx')\n     *\n     * // Connect to a single host with a full set of config details and\n     * // a custom schema\n     * const client = new Influx.InfluxDB({\n     *   database: 'my_db',\n     *   host: 'localhost',\n     *   port: 8086,\n     *   username: 'connor',\n     *   password: 'pa$$w0rd',\n     *   schema: [\n     *     {\n     *       measurement: 'perf',\n     *       fields: {\n     *         memory_usage: Influx.FieldType.INTEGER,\n     *         cpu_usage: Influx.FieldType.FLOAT,\n     *         is_online: Influx.FieldType.BOOLEAN\n     *       }\n     *       tags: [\n     *         'hostname'\n     *       ]\n     *     }\n     *   ]\n     * })\n     *\n     * @example\n     * const Influx = require('influx')\n     *\n     * // Use a pool of several host connections and balance queries across them:\n     * const client = new Influx.InfluxDB({\n     *   database: 'my_db',\n     *   username: 'connor',\n     *   password: 'pa$$w0rd',\n     *   hosts: [\n     *     { host: 'db1.example.com' },\n     *     { host: 'db2.example.com' },\n     *   ],\n     *   schema: [\n     *     {\n     *       measurement: 'perf',\n     *       fields: {\n     *         memory_usage: Influx.FieldType.INTEGER,\n     *         cpu_usage: Influx.FieldType.FLOAT,\n     *         is_online: Influx.FieldType.BOOLEAN\n     *       }\n     *       tags: [\n     *         'hostname'\n     *       ]\n     *     }\n     *   ]\n     * })\n     *\n     */\n    constructor(options) {\n        /**\n         * Map of Schema instances defining measurements in Influx.\n         * @private\n         */\n        this.schema = Object.create(null);\n        // Figure out how to parse whatever we were passed in into a IClusterConfig.\n        if (typeof options === 'string') {\n            options = parseOptionsUrl(options);\n        }\n        else if (!options) {\n            options = defaultHost;\n        }\n        if (!options.hasOwnProperty('hosts')) {\n            options = {\n                database: options.database,\n                hosts: [options],\n                password: options.password,\n                pool: options.pool,\n                schema: options.schema,\n                username: options.username,\n            };\n        }\n        const resolved = options;\n        resolved.hosts = resolved.hosts.map(host => {\n            return defaults({\n                host: host.host,\n                port: host.port,\n                protocol: host.protocol,\n            }, defaultHost);\n        });\n        this.pool = new Pool(resolved.pool);\n        this.options = defaults(resolved, defaultOptions);\n        resolved.hosts.forEach(host => {\n            this.pool.addHost(`${host.protocol}://${host.host}:${host.port}`);\n        });\n        this.options.schema.forEach(schema => {\n            const db = schema.database = schema.database || this.options.database;\n            if (!db) {\n                throw new Error(`Schema ${schema.measurement} doesn't have a database specified,` +\n                    'and no default database is provided!');\n            }\n            if (!this.schema[db]) {\n                this.schema[db] = Object.create(null);\n            }\n            this.schema[db][schema.measurement] = new Schema(schema);\n        });\n    }\n    /**\n     * Creates a new database with the provided name.\n     * @param {string} databaseName\n     * @return {Promise.<void>}\n     * @example\n     * influx.createDatabase('mydb')\n     */\n    createDatabase(databaseName) {\n        return this.pool.json(this.getQueryOpts({\n            q: `create database ${grammar.escape.quoted(databaseName)}`,\n        }, 'POST')).then(assertNoErrors);\n    }\n    /**\n     * Deletes a database with the provided name.\n     * @param {string} databaseName\n     * @return {Promise.<void>}\n     * @example\n     * influx.createDatabase('mydb')\n     */\n    dropDatabase(databaseName) {\n        return this.pool.json(this.getQueryOpts({\n            q: `drop database ${grammar.escape.quoted(databaseName)}`,\n        }, 'POST')).then(assertNoErrors);\n    }\n    /**\n     * Returns array of database names. Requires cluster admin privileges.\n     * @returns {Promise<String[]>} a list of database names\n     * @example\n     * influx.getMeasurements().then(names =>\n     *   console.log('My database names are: ' + names.join(', ')));\n     */\n    getDatabaseNames() {\n        return this.pool.json(this.getQueryOpts({ q: 'show databases' }))\n            .then(res => parseSingle(res).map(r => r.name));\n    }\n    /**\n     * Returns array of measurements.\n     * @returns {Promise<String[]>} a list of measurement names\n     * @param {String} [database] the database the measurement lives in, optional\n     *     if a default database is provided.\n     * @example\n     * influx.getMeasurements().then(names =>\n     *   console.log('My measurement names are: ' + names.join(', ')));\n     */\n    getMeasurements(database = this.defaultDB()) {\n        return this.pool.json(this.getQueryOpts({\n            db: database,\n            q: 'show measurements',\n        })).then(res => parseSingle(res).map(r => r.name));\n    }\n    /**\n     * Returns a list of all series within the target measurement, or from the\n     * entire database if a measurement isn't provided.\n     * @param {Object} [options]\n     * @param {String} [options.measurement] if provided, we'll only get series\n     *     from within that measurement.\n     * @param {String} [options.database] the database the series lives in,\n     *     optional if a default database is provided.\n     * @returns {Promise<String[]>} a list of series names\n     * @example\n     * influx.getSeries().then(names => {\n     *   console.log('My series names in my_measurement are: ' + names.join(', '))\n     * })\n     *\n     * influx.getSeries({\n     *   measurement: 'my_measurement',\n     *   database: 'my_db'\n     * }).then(names => {\n     *   console.log('My series names in my_measurement are: ' + names.join(', '))\n     * })\n     */\n    getSeries(options = {}) {\n        const { database = this.defaultDB(), measurement, } = options;\n        let query = 'show series';\n        if (measurement) {\n            query += ` from ${grammar.escape.quoted(measurement)}`;\n        }\n        return this.pool.json(this.getQueryOpts({\n            db: database,\n            q: query,\n        })).then(res => parseSingle(res).map(r => r.key));\n    }\n    /**\n     * Removes a measurement from the database.\n     * @param {String} measurement\n     * @param {String} [database] the database the measurement lives in, optional\n     *     if a default database is provided.\n     * @return {Promise.<void>}\n     * @example\n     * influx.dropMeasurement('my_measurement')\n     */\n    dropMeasurement(measurement, database = this.defaultDB()) {\n        return this.pool.json(this.getQueryOpts({\n            db: database,\n            q: `drop measurement ${grammar.escape.quoted(measurement)}`,\n        }, 'POST')).then(assertNoErrors);\n    }\n    /**\n     * Removes a one or more series from InfluxDB.\n     *\n     * @returns {Promise<void>}\n     * @example\n     * // The following pairs of queries are equivalent: you can chose either to\n     * // use our builder or pass in string directly. The builder takes care\n     * // of escaping and most syntax handling for you.\n     *\n     * influx.dropSeries({ where: e => e.tag('cpu').equals.value('cpu8') })\n     * influx.dropSeries({ where: '\"cpu\" = \\'cpu8\\'' })\n     * // DROP SERIES WHERE \"cpu\" = 'cpu8'\n     *\n     * influx.dropSeries({ measurement: m => m.name('cpu').policy('autogen') })\n     * influx.dropSeries({ measurement: '\"cpu\".\"autogen\"' })\n     * // DROP SERIES FROM \"autogen\".\"cpu\"\n     *\n     * influx.dropSeries({\n     *   measurement: m => m.name('cpu').policy('autogen'),\n     *   where: e => e.tag('cpu').equals.value('cpu8'),\n     *   database: 'my_db'\n     * })\n     * // DROP SERIES FROM \"autogen\".\"cpu\" WHERE \"cpu\" = 'cpu8'\n     */\n    dropSeries(options) {\n        const db = 'database' in options ? options.database : this.defaultDB();\n        let q = 'drop series';\n        if ('measurement' in options) {\n            q += ' from ' + b.parseMeasurement(options);\n        }\n        if ('where' in options) {\n            q += ' where ' + b.parseWhere(options);\n        }\n        return this.pool.json(this.getQueryOpts({ db, q }, 'POST')).then(assertNoErrors);\n    }\n    /**\n     * Returns a list of users on the Influx database.\n     * @return {Promise<Array<{ user: String, admin: Boolean }>>}\n     * @example\n     * influx.getUsers().then(users => {\n     *   users.forEach(user => {\n     *     if (user.admin) {\n     *       console.log(user.user, 'is an admin!')\n     *     } else {\n     *       console.log(user.user, 'is not an admin!')\n     *     }\n     *   })\n     * })\n     */\n    getUsers() {\n        return this.pool.json(this.getQueryOpts({ q: 'show users' })).then(parseSingle);\n    }\n    /**\n     * Creates a new InfluxDB user.\n     * @param {String} username\n     * @param {String} password\n     * @param {Boolean} [admin=false] If true, the user will be given all\n     *     privileges on all databases.\n     * @returns {Promise<void>}\n     * @example\n     * influx.createUser('connor', 'pa55w0rd', true) // make 'connor' an admin\n     *\n     * // make non-admins:\n     * influx.createUser('not_admin', 'pa55w0rd')\n     */\n    createUser(username, password, admin = false) {\n        return this.pool.json(this.getQueryOpts({\n            q: `create user ${grammar.escape.quoted(username)} with password `\n                + grammar.escape.stringLit(password)\n                + (admin ? ' with all privileges' : ''),\n        }, 'POST')).then(assertNoErrors);\n    }\n    /**\n     * Sets a password for an Influx user.\n     * @param {String} username\n     * @param {String} password\n     * @returns {Promise<void>}\n     * @example\n     * influx.setPassword('connor', 'pa55w0rd')\n     */\n    setPassword(username, password) {\n        return this.pool.json(this.getQueryOpts({\n            q: `set password for ${grammar.escape.quoted(username)} = `\n                + grammar.escape.stringLit(password),\n        }, 'POST')).then(assertNoErrors);\n    }\n    /**\n     * Grants a privilege to a specified user.\n     * @param {String} username\n     * @param {String} privilege Should be one of 'READ' or 'WRITE'\n     * @param {String} [database] If not provided, uses the default database.\n     * @returns {Promise<void>}\n     * @example\n     * influx.grantPrivilege('connor', 'READ', 'my_db') // grants read access on my_db to connor\n     */\n    grantPrivilege(username, privilege, database = this.defaultDB()) {\n        return this.pool.json(this.getQueryOpts({\n            q: `grant ${privilege} on ${grammar.escape.quoted(database)} `\n                + `to ${grammar.escape.quoted(username)}`,\n        }, 'POST')).then(assertNoErrors);\n    }\n    /**\n     * Removes a privilege from a specified user.\n     * @param {String} username\n     * @param {String} privilege Should be one of 'READ' or 'WRITE'\n     * @param {String} [database] If not provided, uses the default database.\n     * @returns {Promise<void>}\n     * @example\n     * influx.revokePrivilege('connor', 'READ', 'my_db') // removes read access on my_db from connor\n     */\n    revokePrivilege(username, privilege, database = this.defaultDB()) {\n        return this.pool.json(this.getQueryOpts({\n            q: `revoke ${privilege} from ${grammar.escape.quoted(username)} on `\n                + grammar.escape.quoted(database),\n        }, 'POST')).then(assertNoErrors);\n    }\n    /**\n     * Grants admin privileges to a specified user.\n     * @param {String} username\n     * @returns {Promise<void>}\n     * @example\n     * influx.grantAdminPrivilege('connor')\n     */\n    grantAdminPrivilege(username) {\n        return this.pool.json(this.getQueryOpts({\n            q: `grant all to ${grammar.escape.quoted(username)}`,\n        }, 'POST')).then(assertNoErrors);\n    }\n    /**\n     * Removes a admin privilege from a specified user.\n     * @param {String} username\n     * @returns {Promise<void>}\n     * @example\n     * influx.revokeAdminPrivilege('connor')\n     */\n    revokeAdminPrivilege(username) {\n        return this.pool.json(this.getQueryOpts({\n            q: `revoke all from ${grammar.escape.quoted(username)}`,\n        }, 'POST')).then(assertNoErrors);\n    }\n    /**\n     * Removes a user from the database.\n     * @param {String} username\n     * @returns {Promise<void>}\n     * @example\n     * influx.dropUser('connor')\n     */\n    dropUser(username) {\n        return this.pool.json(this.getQueryOpts({\n            q: `drop user ${grammar.escape.quoted(username)}`,\n        }, 'POST')).then(assertNoErrors);\n    }\n    /**\n     * Creates a continuous query in a database\n     * @param {String} name The query name, for later reference\n     * @param {String} query The body of the query to run\n     * @param {String} [database] If not provided, uses the default database.\n     * @returns {Promise<void>}\n     * @example\n     * influx.createContinuousQuery('downsample_cpu_1h', `\n     *   SELECT MEAN(cpu) INTO \"7d\".\"perf\"\n     *   FROM \"1d\".\"perf\" GROUP BY time(1m)\n     * `)\n     */\n    createContinuousQuery(name, query, database = this.defaultDB()) {\n        return this.pool.json(this.getQueryOpts({\n            q: `create continuous query ${grammar.escape.quoted(name)}`\n                + ` on ${grammar.escape.quoted(database)} begin ${query} end`,\n        }, 'POST')).then(assertNoErrors);\n    }\n    /**\n     * Returns a list of continous queries in the database.\n     * @param {String} [database] If not provided, uses the default database.\n     * @returns {Promise<void>}\n     * @example\n     * influx.showContinousQueries()\n     */\n    showContinousQueries(database = this.defaultDB()) {\n        return this.pool.json(this.getQueryOpts({\n            db: database,\n            q: 'show continuous queries',\n        })).then(parseSingle);\n    }\n    /**\n     * Creates a continuous query in a database\n     * @param {String} name The query name\n     * @param {String} [database] If not provided, uses the default database.\n     * @returns {Promise<void>}\n     * @example\n     * influx.dropContinuousQuery('downsample_cpu_1h')\n     */\n    dropContinuousQuery(name, database = this.defaultDB()) {\n        return this.pool.json(this.getQueryOpts({\n            q: `drop continuous query ${grammar.escape.quoted(name)}`\n                + ` on ${grammar.escape.quoted(database)}`,\n        }, 'POST')).then(assertNoErrors);\n    }\n    /**\n     * Creates a new retention policy on a database. You can read more about\n     * [Downsampling and Retention](https://docs.influxdata.com/influxdb/v1.0/\n     * guides/downsampling_and_retention/) on the InfluxDB website.\n     *\n     * @param {String} name The retention policy name\n     * @param {Object} options\n     * @param {String} [options.database] Database to create the policy on,\n     *     uses the default database if not provided.\n     * @param {String} options.duration How long data in the retention policy\n     *     should be stored for, should be in a format like `7d`. See details\n     *     [here](https://docs.influxdata.com/influxdb/v1.0/query_language/spec/#durations)\n     * @param {Number} options.replication How many servers data in the series\n     *     should be replicated to.\n     * @param {Boolean} [options.isDefault] Whether the retention policy should\n     *     be the default policy on the database.\n     * @returns {Promise<void>}\n     * @example\n     * influx.createRetentionPolicy('7d', {\n     *  duration: '7d',\n     *  replication: 1\n     * })\n     */\n    createRetentionPolicy(name, options) {\n        const q = `create retention policy ${grammar.escape.quoted(name)} on `\n            + grammar.escape.quoted(options.database || this.defaultDB())\n            + ` duration ${options.duration} replication ${options.replication}`\n            + (options.isDefault ? ' default' : '');\n        return this.pool.json(this.getQueryOpts({ q }, 'POST')).then(assertNoErrors);\n    }\n    /**\n     * Alters an existing retention policy on a database.\n     *\n     * @param {String} name The retention policy name\n     * @param {Object} options\n     * @param {String} [options.database] Database to create the policy on,\n     *     uses the default database if not provided.\n     * @param {String} options.duration How long data in the retention policy\n     *     should be stored for, should be in a format like `7d`. See details\n     *     [here](https://docs.influxdata.com/influxdb/v1.0/query_language/spec/#durations)\n     * @param {Number} options.replication How many servers data in the series\n     *     should be replicated to.\n     * @param {Boolean} [options.default] Whether the retention policy should\n     *     be the default policy on the database.\n     * @returns {Promise<void>}\n     * @example\n     * influx.alterRetentionPolicy('7d', {\n     *  duration: '7d',\n     *  replication: 1,\n     *  default: true\n     * })\n     */\n    alterRetentionPolicy(name, options) {\n        const q = `alter retention policy ${grammar.escape.quoted(name)} on `\n            + grammar.escape.quoted(options.database || this.defaultDB())\n            + ` duration ${options.duration} replication ${options.replication}`\n            + (options.isDefault ? ' default' : '');\n        return this.pool.json(this.getQueryOpts({ q }, 'POST')).then(assertNoErrors);\n    }\n    /**\n     * Deletes a retention policy and associated data. Note that the data will\n     * not be immediately destroyed, and will hang around until Influx's\n     * bi-hourly cron.\n     *\n     * @param {String} name The retention policy name\n     * @param {String} [database] Database name that the policy lives in,\n     *     uses the default database if not provided.\n     * @returns {Promise<void>}\n     * @example\n     * influx.dropRetentionPolicy('7d')\n     */\n    dropRetentionPolicy(name, database = this.defaultDB()) {\n        return this.pool.json(this.getQueryOpts({\n            q: `drop retention policy ${grammar.escape.quoted(name)} `\n                + `on ${grammar.escape.quoted(database)}`,\n        }, 'POST')).then(assertNoErrors);\n    }\n    /**\n     * Shows retention policies on the database\n     *\n     * @param {String} [database] The database to list policies on, uses the\n     *     default database if not provided.\n     * @returns {Promise<Array<{\n     *     name: String,\n     *     duration: String,\n     *     shardGroupDuration: String,\n     *     replicaN: Number,\n     *     default: Boolean\n     * }>>}\n     * @example\n     * influx.showRetentionPolicies().then(policies => {\n     *   expect(policies.slice()).to.deep.equal([\n     *     {\n     *       name: 'autogen',\n     *       duration: '0s',\n     *       shardGroupDuration: '168h0m0s',\n     *       replicaN: 1,\n     *       default: true,\n     *     },\n     *     {\n     *       name: '7d',\n     *       duration: '168h0m0s',\n     *       shardGroupDuration: '24h0m0s',\n     *       replicaN: 1,\n     *       default: false,\n     *     },\n     *   ])\n     * })\n     */\n    showRetentionPolicies(database = this.defaultDB()) {\n        return this.pool.json(this.getQueryOpts({\n            q: `show retention policies on ${grammar.escape.quoted(database)}`,\n        }, 'GET')).then(parseSingle);\n    }\n    /**\n     * writePoints sends a list of points together in a batch to InfluxDB. In\n     * each point you must specify the measurement name to write into as well\n     * as a list of tag and field values. Optionally, you can specify the\n     * time to tag that point at, defaulting to the current time.\n     *\n     * If you defined a schema for the measurement in the options you passed\n     * to `new Influx(options)`, we'll use that to make sure that types get\n     * cast correctly and that there are no extraneous fields or columns.\n     *\n     * For best performance, it's recommended that you batch your data into\n     * sets of a couple thousand records before writing it. In the future we'll\n     * have some utilities within node-influx to make this easier.\n     *\n     * ---\n     *\n     * A note when using manually-specified times and precisions: by default\n     * we write using the `ms` precision since that's what JavaScript gives us.\n     * You can adjust this. However, there is some special behaviour if you\n     * manually specify a timestamp in your points:\n     *  - if you specify the timestamp as a Date object, we'll convert it to\n     *    milliseconds and manipulate it as needed to get the right precision\n     *  - if provide a INanoDate as returned from {@link toNanoTime} or the\n     *    results from an Influx query, we'll be able to pull the precise\n     *    nanosecond timestamp and manipulate it to get the right precision\n     *  - if you provide a string or number as the timestamp, we'll pass it\n     *    straight into Influx.\n     *\n     * Please see the IPoint and IWriteOptions type for a\n     * full list of possible options.\n     *\n     * @param {Point[]} points\n     * @param {IWriteOptions} [options]\n     * @return {Promise<void>}\n     * @example\n     * // write a point into the default database with\n     * // the default retention policy.\n     * influx.writePoints([\n     *   {\n     *     measurement: 'perf',\n     *     tags: { host: 'box1.example.com' },\n     *     fields: { cpu: getCpuUsage(), mem: getMemUsage() },\n     *   }\n     * ])\n     *\n     * // you can manually specify the database,\n     * // retention policy, and time precision:\n     * influx.writePoints([\n     *   {\n     *     measurement: 'perf',\n     *     tags: { host: 'box1.example.com' },\n     *     fields: { cpu: getCpuUsage(), mem: getMemUsage() },\n     *     timestamp: getLastRecordedTime(),\n     *   }\n     * ], {\n     *   database: 'my_db',\n     *   retentionPolicy: '1d',\n     *   precision: 's'\n     * })\n     */\n    writePoints(points, options = {}) {\n        const { database = this.defaultDB(), precision = 'n', retentionPolicy, } = options;\n        let payload = '';\n        points.forEach(point => {\n            const { fields = {}, tags = {}, measurement, timestamp, } = point;\n            const schema = this.schema[database] && this.schema[database][measurement];\n            const fieldsPairs = schema ? schema.coerceFields(fields) : coerceBadly(fields);\n            const tagsNames = schema ? schema.checkTags(tags) : Object.keys(tags);\n            payload += (payload.length > 0 ? '\\n' : '') + measurement;\n            for (let i = 0; i < tagsNames.length; i += 1) {\n                payload += ','\n                    + grammar.escape.tag(tagsNames[i])\n                    + '='\n                    + grammar.escape.tag(tags[tagsNames[i]]);\n            }\n            for (let i = 0; i < fieldsPairs.length; i += 1) {\n                payload += (i === 0 ? ' ' : ',')\n                    + grammar.escape.tag(fieldsPairs[i][0])\n                    + '='\n                    + fieldsPairs[i][1];\n            }\n            if (timestamp !== undefined) {\n                payload += ' ' + grammar.castTimestamp(timestamp, precision);\n            }\n        });\n        return this.pool.discard({\n            body: payload,\n            method: 'POST',\n            path: '/write',\n            query: Object.assign({\n                db: database,\n                p: this.options.password,\n                precision,\n                rp: retentionPolicy,\n                u: this.options.username,\n            }),\n        });\n    }\n    /**\n     * writeMeasurement functions similarly to {@link InfluxDB#writePoints}, but\n     * it automatically fills in the `measurement` value for all points for you.\n     *\n     * @param {String} measurement\n     * @param {Point[]} points\n     * @param {IWriteOptions} [options]\n     * @return {Promise<void>}\n     * @example\n     * influx.writeMeasurement('perf', [\n     *   {\n     *     tags: { host: 'box1.example.com' },\n     *     fields: { cpu: getCpuUsage(), mem: getMemUsage() },\n     *   }\n     * ])\n     */\n    writeMeasurement(measurement, points, options = {}) {\n        points = points.map(p => Object.assign({ measurement }, p));\n        return this.writePoints(points, options);\n    }\n    /**\n     * .query() run a query (or list of queries), runs them, and returns the\n     * results in a friendly format. If you run multiple queries, multiple\n     * sets of results will be returned, otherwise a single result will\n     * be returned.\n     *\n     * @param {String|String[]} query\n     * @param {IQueryOptions} [options]\n     * @return {Promise<IResults|Results[]>} query\n     * @example\n     * influx.query('select * from perf').then(results => {\n     *   console.log(results)\n     * })\n     */\n    query(query, options = {}) {\n        if (Array.isArray(query)) {\n            query = query.join(';');\n        }\n        // If the consumer asked explicitly for nanosecond precision parsing,\n        // remove that to cause Influx to give us ISO dates that\n        // we can parse correctly.\n        if (options.precision === 'n') {\n            options = Object.assign({}, options); // avoid mutating\n            delete options.precision;\n        }\n        return this.queryRaw(query, options).then(res => parse(res, options.precision));\n    }\n    /**\n     * queryRaw functions similarly to .query() but it does no fancy\n     * transformations on the returned data; it calls `JSON.parse` and returns\n     * those results verbatim.\n     *\n     * @param {String|String[]} query\n     * @param {IQueryOptions} [options]\n     * @return {Promise<*>}\n     * @example\n     * influx.queryRaw('select * from perf').then(rawData => {\n     *   console.log(rawData)\n     * })\n     */\n    queryRaw(query, options = {}) {\n        const { database = this.defaultDB(), retentionPolicy, } = options;\n        return this.pool.json(this.getQueryOpts({\n            db: database,\n            epoch: options.precision,\n            q: query,\n            rp: retentionPolicy,\n        }));\n    }\n    /**\n     * Pings all available hosts, collecting online status and version info.\n     * @param  {Number}               timeout Given in milliseconds\n     * @return {Promise<IPingStats[]>}\n     * @example\n     * influx.ping(5000).then(hosts => {\n     *   hosts.forEach(host => {\n     *     if (host.online) {\n     *       console.log(`${host.url.host} responded in ${host.rtt}ms running ${host.version})`)\n     *     } else {\n     *       console.log(`${host.url.host} is offline :(`)\n     *     }\n     *   })\n     * })\n     */\n    ping(timeout) {\n        return this.pool.ping(timeout);\n    }\n    /**\n     * Returns the default database that queries operates on. It throws if called\n     * when a default database isn't set.\n     * @private\n     */\n    defaultDB() {\n        if (!this.options.database) {\n            throw new Error('Attempted to run an influx query without a default'\n                + ' database specified or an explicit database provided.');\n        }\n        return this.options.database;\n    }\n    /**\n     * Creates options to be passed into the pool to query databases.\n     * @private\n     */\n    getQueryOpts(params, method = 'GET') {\n        return {\n            method,\n            path: '/query',\n            query: Object.assign({\n                p: this.options.password,\n                u: this.options.username,\n            }, params),\n        };\n    }\n}\n",
    "importPath": "influx"
  },
  {
    "__docId__": 114,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "defaultHost",
    "memberof": "src/index.js",
    "longname": "src/index.js~defaultHost",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 115,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "defaultOptions",
    "memberof": "src/index.js",
    "longname": "src/index.js~defaultOptions",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 116,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "parseOptionsUrl",
    "memberof": "src/index.js",
    "longname": "src/index.js~parseOptionsUrl",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": "Parses the URL out into into a IClusterConfig object",
    "lineNumber": 25,
    "params": [
      {
        "name": "addr",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 117,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "defaults",
    "memberof": "src/index.js",
    "longname": "src/index.js~defaults",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": "Works similarly to Object.assign, but only overwrites\nproperties that resolve to undefined.",
    "lineNumber": 44,
    "params": [
      {
        "name": "target",
        "types": [
          "*"
        ]
      },
      {
        "name": "srcs",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 118,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "InfluxDB",
    "memberof": "src/index.js",
    "longname": "src/index.js~InfluxDB",
    "access": null,
    "export": true,
    "importPath": "influx",
    "importStyle": "{InfluxDB}",
    "description": "InfluxDB is the public interface to run queries against the your database.\nThis is a 'driver-level' module, not a a full-fleged ORM or ODM; you run\nqueries directly by calling methods on this class.\n\nPlease check out some of [the tutorials](https://node-influx.github.io/manual/tutorial.html)\nif you want help getting started!",
    "examples": [
      "const Influx = require('influx');\nconst influx = new Influx.InfluxDB({\n host: 'localhost',\n database: 'express_response_db',\n schema: [\n   {\n     measurement: 'response_times',\n     fields: {\n       path: Influx.FieldType.STRING,\n       duration: Influx.FieldType.INTEGER\n     },\n     tags: [\n       'host'\n     ]\n   }\n ]\n})\n\ninflux.writePoints([\n  {\n    measurement: 'response_times',\n    tags: { host: os.hostname() },\n    fields: { duration, path: req.path },\n  }\n]).then(() => {\n  return influx.query(`\n    select * from response_times\n    where host = ${Influx.escape.stringLit(os.hostname())}\n    order by time desc\n    limit 10\n  `)\n}).then(rows => {\n  rows.forEach(row => console.log(`A request to ${row.path} took ${row.duration}ms`))\n})"
    ],
    "lineNumber": 98,
    "interface": false
  },
  {
    "__docId__": 119,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#constructor",
    "access": null,
    "description": "Connect to a single InfluxDB instance by specifying\na set of connection options.",
    "examples": [
      "const Influx = require('influx')\n\n// Connect to a single host with a DSN:\nconst influx = new Influx.InfluxDB('http://user:password@host:8086/database')",
      "const Influx = require('influx')\n\n// Connect to a single host with a full set of config details and\n// a custom schema\nconst client = new Influx.InfluxDB({\n  database: 'my_db',\n  host: 'localhost',\n  port: 8086,\n  username: 'connor',\n  password: 'pa$$w0rd',\n  schema: [\n    {\n      measurement: 'perf',\n      fields: {\n        memory_usage: Influx.FieldType.INTEGER,\n        cpu_usage: Influx.FieldType.FLOAT,\n        is_online: Influx.FieldType.BOOLEAN\n      }\n      tags: [\n        'hostname'\n      ]\n    }\n  ]\n})",
      "const Influx = require('influx')\n\n// Use a pool of several host connections and balance queries across them:\nconst client = new Influx.InfluxDB({\n  database: 'my_db',\n  username: 'connor',\n  password: 'pa$$w0rd',\n  hosts: [\n    { host: 'db1.example.com' },\n    { host: 'db2.example.com' },\n  ],\n  schema: [\n    {\n      measurement: 'perf',\n      fields: {\n        memory_usage: Influx.FieldType.INTEGER,\n        cpu_usage: Influx.FieldType.FLOAT,\n        is_online: Influx.FieldType.BOOLEAN\n      }\n      tags: [\n        'hostname'\n      ]\n    }\n  ]\n})"
    ],
    "lineNumber": 164,
    "params": [
      {
        "nullable": null,
        "types": [
          "IClusterConfig",
          "ISingleHostConfig",
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'http://root:root@127.0.0.1:8086'",
        "defaultRaw": "'http://root:root@127.0.0.1:8086'",
        "name": "options",
        "description": ""
      }
    ],
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 120,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "schema",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#schema",
    "access": "private",
    "description": "Map of Schema instances defining measurements in Influx.",
    "lineNumber": 169,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 121,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "pool",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#pool",
    "access": null,
    "description": null,
    "lineNumber": 195,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 122,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "options",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#options",
    "access": null,
    "description": null,
    "lineNumber": 196,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 123,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "createDatabase",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#createDatabase",
    "access": null,
    "description": "Creates a new database with the provided name.",
    "examples": [
      "influx.createDatabase('mydb')"
    ],
    "lineNumber": 219,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "databaseName",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 124,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "dropDatabase",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#dropDatabase",
    "access": null,
    "description": "Deletes a database with the provided name.",
    "examples": [
      "influx.createDatabase('mydb')"
    ],
    "lineNumber": 231,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "databaseName",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 125,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getDatabaseNames",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#getDatabaseNames",
    "access": null,
    "description": "Returns array of database names. Requires cluster admin privileges.",
    "examples": [
      "influx.getMeasurements().then(names =>\n  console.log('My database names are: ' + names.join(', ')));"
    ],
    "lineNumber": 243,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<String[]>} a list of database names"
      }
    ],
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise<String[]>"
      ],
      "spread": false,
      "description": "a list of database names"
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 126,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getMeasurements",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#getMeasurements",
    "access": null,
    "description": "Returns array of measurements.",
    "examples": [
      "influx.getMeasurements().then(names =>\n  console.log('My measurement names are: ' + names.join(', ')));"
    ],
    "lineNumber": 256,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<String[]>} a list of measurement names"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "the database the measurement lives in, optional\n    if a default database is provided."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<String[]>"
      ],
      "spread": false,
      "description": "a list of measurement names"
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 127,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getSeries",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#getSeries",
    "access": null,
    "description": "Returns a list of all series within the target measurement, or from the\nentire database if a measurement isn't provided.",
    "examples": [
      "influx.getSeries().then(names => {\n  console.log('My series names in my_measurement are: ' + names.join(', '))\n})\n\ninflux.getSeries({\n  measurement: 'my_measurement',\n  database: 'my_db'\n}).then(names => {\n  console.log('My series names in my_measurement are: ' + names.join(', '))\n})"
    ],
    "lineNumber": 283,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<String[]>} a list of series names"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "options.measurement",
        "description": "if provided, we'll only get series\n    from within that measurement."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "options.database",
        "description": "the database the series lives in,\n    optional if a default database is provided."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<String[]>"
      ],
      "spread": false,
      "description": "a list of series names"
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 128,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "dropMeasurement",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#dropMeasurement",
    "access": null,
    "description": "Removes a measurement from the database.",
    "examples": [
      "influx.dropMeasurement('my_measurement')"
    ],
    "lineNumber": 303,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "measurement",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "the database the measurement lives in, optional\n    if a default database is provided."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 129,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "dropSeries",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#dropSeries",
    "access": null,
    "description": "Removes a one or more series from InfluxDB.",
    "examples": [
      "// The following pairs of queries are equivalent: you can chose either to\n// use our builder or pass in string directly. The builder takes care\n// of escaping and most syntax handling for you.\n\ninflux.dropSeries({ where: e => e.tag('cpu').equals.value('cpu8') })\ninflux.dropSeries({ where: '\"cpu\" = \\'cpu8\\'' })\n// DROP SERIES WHERE \"cpu\" = 'cpu8'\n\ninflux.dropSeries({ measurement: m => m.name('cpu').policy('autogen') })\ninflux.dropSeries({ measurement: '\"cpu\".\"autogen\"' })\n// DROP SERIES FROM \"autogen\".\"cpu\"\n\ninflux.dropSeries({\n  measurement: m => m.name('cpu').policy('autogen'),\n  where: e => e.tag('cpu').equals.value('cpu8'),\n  database: 'my_db'\n})\n// DROP SERIES FROM \"autogen\".\"cpu\" WHERE \"cpu\" = 'cpu8'"
    ],
    "lineNumber": 333,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 130,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getUsers",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#getUsers",
    "access": null,
    "description": "Returns a list of users on the Influx database.",
    "examples": [
      "influx.getUsers().then(users => {\n  users.forEach(user => {\n    if (user.admin) {\n      console.log(user.user, 'is an admin!')\n    } else {\n      console.log(user.user, 'is not an admin!')\n    }\n  })\n})"
    ],
    "lineNumber": 358,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Array<{ user: String, admin: Boolean }>>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 131,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "createUser",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#createUser",
    "access": null,
    "description": "Creates a new InfluxDB user.",
    "examples": [
      "influx.createUser('connor', 'pa55w0rd', true) // make 'connor' an admin\n\n// make non-admins:\ninflux.createUser('not_admin', 'pa55w0rd')"
    ],
    "lineNumber": 374,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "password",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "admin",
        "description": "If true, the user will be given all\n    privileges on all databases."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 132,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "setPassword",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#setPassword",
    "access": null,
    "description": "Sets a password for an Influx user.",
    "examples": [
      "influx.setPassword('connor', 'pa55w0rd')"
    ],
    "lineNumber": 389,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "password",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 133,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "grantPrivilege",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#grantPrivilege",
    "access": null,
    "description": "Grants a privilege to a specified user.",
    "examples": [
      "influx.grantPrivilege('connor', 'READ', 'my_db') // grants read access on my_db to connor"
    ],
    "lineNumber": 404,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "privilege",
        "description": "Should be one of 'READ' or 'WRITE'"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "If not provided, uses the default database."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 134,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "revokePrivilege",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#revokePrivilege",
    "access": null,
    "description": "Removes a privilege from a specified user.",
    "examples": [
      "influx.revokePrivilege('connor', 'READ', 'my_db') // removes read access on my_db from connor"
    ],
    "lineNumber": 419,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "privilege",
        "description": "Should be one of 'READ' or 'WRITE'"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "If not provided, uses the default database."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 135,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "grantAdminPrivilege",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#grantAdminPrivilege",
    "access": null,
    "description": "Grants admin privileges to a specified user.",
    "examples": [
      "influx.grantAdminPrivilege('connor')"
    ],
    "lineNumber": 432,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 136,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "revokeAdminPrivilege",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#revokeAdminPrivilege",
    "access": null,
    "description": "Removes a admin privilege from a specified user.",
    "examples": [
      "influx.revokeAdminPrivilege('connor')"
    ],
    "lineNumber": 444,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 137,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "dropUser",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#dropUser",
    "access": null,
    "description": "Removes a user from the database.",
    "examples": [
      "influx.dropUser('connor')"
    ],
    "lineNumber": 456,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 138,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "createContinuousQuery",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#createContinuousQuery",
    "access": null,
    "description": "Creates a continuous query in a database",
    "examples": [
      "influx.createContinuousQuery('downsample_cpu_1h', `\n  SELECT MEAN(cpu) INTO \"7d\".\"perf\"\n  FROM \"1d\".\"perf\" GROUP BY time(1m)\n`)"
    ],
    "lineNumber": 473,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The query name, for later reference"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "The body of the query to run"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "If not provided, uses the default database."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 139,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "showContinousQueries",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#showContinousQueries",
    "access": null,
    "description": "Returns a list of continous queries in the database.",
    "examples": [
      "influx.showContinousQueries()"
    ],
    "lineNumber": 486,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "If not provided, uses the default database."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 140,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "dropContinuousQuery",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#dropContinuousQuery",
    "access": null,
    "description": "Creates a continuous query in a database",
    "examples": [
      "influx.dropContinuousQuery('downsample_cpu_1h')"
    ],
    "lineNumber": 500,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The query name"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "If not provided, uses the default database."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 141,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "createRetentionPolicy",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#createRetentionPolicy",
    "access": null,
    "description": "Creates a new retention policy on a database. You can read more about\n[Downsampling and Retention](https://docs.influxdata.com/influxdb/v1.0/\nguides/downsampling_and_retention/) on the InfluxDB website.",
    "examples": [
      "influx.createRetentionPolicy('7d', {\n duration: '7d',\n replication: 1\n})"
    ],
    "lineNumber": 529,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The retention policy name"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "options.database",
        "description": "Database to create the policy on,\n    uses the default database if not provided."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "options.duration",
        "description": "How long data in the retention policy\n    should be stored for, should be in a format like `7d`. See details\n    [here](https://docs.influxdata.com/influxdb/v1.0/query_language/spec/#durations)"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "options.replication",
        "description": "How many servers data in the series\n    should be replicated to."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.isDefault",
        "description": "Whether the retention policy should\n    be the default policy on the database."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 142,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "alterRetentionPolicy",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#alterRetentionPolicy",
    "access": null,
    "description": "Alters an existing retention policy on a database.",
    "examples": [
      "influx.alterRetentionPolicy('7d', {\n duration: '7d',\n replication: 1,\n default: true\n})"
    ],
    "lineNumber": 558,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The retention policy name"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "options.database",
        "description": "Database to create the policy on,\n    uses the default database if not provided."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "options.duration",
        "description": "How long data in the retention policy\n    should be stored for, should be in a format like `7d`. See details\n    [here](https://docs.influxdata.com/influxdb/v1.0/query_language/spec/#durations)"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "options.replication",
        "description": "How many servers data in the series\n    should be replicated to."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "options.default",
        "description": "Whether the retention policy should\n    be the default policy on the database."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 143,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "dropRetentionPolicy",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#dropRetentionPolicy",
    "access": null,
    "description": "Deletes a retention policy and associated data. Note that the data will\nnot be immediately destroyed, and will hang around until Influx's\nbi-hourly cron.",
    "examples": [
      "influx.dropRetentionPolicy('7d')"
    ],
    "lineNumber": 577,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The retention policy name"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "Database name that the policy lives in,\n    uses the default database if not provided."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 144,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "showRetentionPolicies",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#showRetentionPolicies",
    "access": null,
    "description": "Shows retention policies on the database",
    "examples": [
      "influx.showRetentionPolicies().then(policies => {\n  expect(policies.slice()).to.deep.equal([\n    {\n      name: 'autogen',\n      duration: '0s',\n      shardGroupDuration: '168h0m0s',\n      replicaN: 1,\n      default: true,\n    },\n    {\n      name: '7d',\n      duration: '168h0m0s',\n      shardGroupDuration: '24h0m0s',\n      replicaN: 1,\n      default: false,\n    },\n  ])\n})"
    ],
    "lineNumber": 615,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Array<{\n    name: String,\n    duration: String,\n    shardGroupDuration: String,\n    replicaN: Number,\n    default: Boolean\n}>>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "database",
        "description": "The database to list policies on, uses the\n    default database if not provided."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Array<{\n    name: String,\n    duration: String,\n    shardGroupDuration: String,\n    replicaN: Number,\n    default: Boolean\n}>>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 145,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "writePoints",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#writePoints",
    "access": null,
    "description": "writePoints sends a list of points together in a batch to InfluxDB. In\neach point you must specify the measurement name to write into as well\nas a list of tag and field values. Optionally, you can specify the\ntime to tag that point at, defaulting to the current time.\n\nIf you defined a schema for the measurement in the options you passed\nto `new Influx(options)`, we'll use that to make sure that types get\ncast correctly and that there are no extraneous fields or columns.\n\nFor best performance, it's recommended that you batch your data into\nsets of a couple thousand records before writing it. In the future we'll\nhave some utilities within node-influx to make this easier.\n\n---\n\nA note when using manually-specified times and precisions: by default\nwe write using the `ms` precision since that's what JavaScript gives us.\nYou can adjust this. However, there is some special behaviour if you\nmanually specify a timestamp in your points:\n - if you specify the timestamp as a Date object, we'll convert it to\n   milliseconds and manipulate it as needed to get the right precision\n - if provide a INanoDate as returned from {@link toNanoTime} or the\n   results from an Influx query, we'll be able to pull the precise\n   nanosecond timestamp and manipulate it to get the right precision\n - if you provide a string or number as the timestamp, we'll pass it\n   straight into Influx.\n\nPlease see the IPoint and IWriteOptions type for a\nfull list of possible options.",
    "examples": [
      "// write a point into the default database with\n// the default retention policy.\ninflux.writePoints([\n  {\n    measurement: 'perf',\n    tags: { host: 'box1.example.com' },\n    fields: { cpu: getCpuUsage(), mem: getMemUsage() },\n  }\n])\n\n// you can manually specify the database,\n// retention policy, and time precision:\ninflux.writePoints([\n  {\n    measurement: 'perf',\n    tags: { host: 'box1.example.com' },\n    fields: { cpu: getCpuUsage(), mem: getMemUsage() },\n    timestamp: getLastRecordedTime(),\n  }\n], {\n  database: 'my_db',\n  retentionPolicy: '1d',\n  precision: 's'\n})"
    ],
    "lineNumber": 680,
    "params": [
      {
        "nullable": null,
        "types": [
          "Point[]"
        ],
        "spread": false,
        "optional": false,
        "name": "points",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IWriteOptions"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 146,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "writeMeasurement",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#writeMeasurement",
    "access": null,
    "description": "writeMeasurement functions similarly to {@link InfluxDB#writePoints}, but\nit automatically fills in the `measurement` value for all points for you.",
    "examples": [
      "influx.writeMeasurement('perf', [\n  {\n    tags: { host: 'box1.example.com' },\n    fields: { cpu: getCpuUsage(), mem: getMemUsage() },\n  }\n])"
    ],
    "lineNumber": 734,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "measurement",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Point[]"
        ],
        "spread": false,
        "optional": false,
        "name": "points",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IWriteOptions"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 147,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "query",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#query",
    "access": null,
    "description": ".query() run a query (or list of queries), runs them, and returns the\nresults in a friendly format. If you run multiple queries, multiple\nsets of results will be returned, otherwise a single result will\nbe returned.",
    "examples": [
      "influx.query('select * from perf').then(results => {\n  console.log(results)\n})"
    ],
    "lineNumber": 752,
    "params": [
      {
        "nullable": null,
        "types": [
          "String",
          "String[]"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IQueryOptions"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<IResults",
        "Results[]>"
      ],
      "spread": false,
      "description": "query"
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 148,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "queryRaw",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#queryRaw",
    "access": null,
    "description": "queryRaw functions similarly to .query() but it does no fancy\ntransformations on the returned data; it calls `JSON.parse` and returns\nthose results verbatim.",
    "examples": [
      "influx.queryRaw('select * from perf').then(rawData => {\n  console.log(rawData)\n})"
    ],
    "lineNumber": 778,
    "params": [
      {
        "nullable": null,
        "types": [
          "String",
          "String[]"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IQueryOptions"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 149,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "ping",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#ping",
    "access": null,
    "description": "Pings all available hosts, collecting online status and version info.",
    "examples": [
      "influx.ping(5000).then(hosts => {\n  hosts.forEach(host => {\n    if (host.online) {\n      console.log(`${host.url.host} responded in ${host.rtt}ms running ${host.version})`)\n    } else {\n      console.log(`${host.url.host} is offline :(`)\n    }\n  })\n})"
    ],
    "lineNumber": 802,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "timeout",
        "description": "Given in milliseconds"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<IPingStats[]>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 150,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "defaultDB",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#defaultDB",
    "access": "private",
    "description": "Returns the default database that queries operates on. It throws if called\nwhen a default database isn't set.",
    "lineNumber": 810,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 151,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getQueryOpts",
    "memberof": "src/index.js~InfluxDB",
    "longname": "src/index.js~InfluxDB#getQueryOpts",
    "access": "private",
    "description": "Creates options to be passed into the pool to query databases.",
    "lineNumber": 821,
    "params": [
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "method",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "GET",
        "defaultValue": "GET"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 152,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/pool.js",
    "memberof": null,
    "longname": "src/pool.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import { ExponentialBackoff } from './backoff/exponential';\nimport { Host } from './host';\nimport * as http from 'http';\nimport * as https from 'https';\nimport * as querystring from 'querystring';\n/**\n * Status codes that will cause a host to be marked as 'failed' if we get\n * them from a request to Influx.\n * @type {Array}\n */\nconst resubmitErrorCodes = [\n    'ETIMEDOUT',\n    'ESOCKETTIMEDOUT',\n    'ECONNRESET',\n    'ECONNREFUSED',\n    'EHOSTUNREACH',\n];\n/**\n * An ServiceNotAvailableError is returned as an error from requests that\n * result in a > 500 error code.\n */\nexport class ServiceNotAvailableError extends Error {\n    constructor(message) {\n        super();\n        this.message = message;\n    }\n}\n/**\n * An RequestError is returned as an error from requests that\n * result in a 300 <= error code <= 500.\n */\nexport class RequestError extends Error {\n    constructor(req, res, body) {\n        super();\n        this.req = req;\n        this.res = res;\n        this.message = `A ${res.statusCode} ${res.statusMessage} error occurred: ${body}`;\n    }\n    static Create(req, res, callback) {\n        let body = '';\n        res.on('data', str => body = body + str.toString());\n        res.on('end', () => callback(new RequestError(req, res, body)));\n    }\n}\n/**\n * Creates a function generation that returns a wrapper which only allows\n * through the first call of any function that it generated.\n */\nfunction doOnce() {\n    let handled = false;\n    return fn => {\n        return arg => {\n            if (handled) {\n                return;\n            }\n            handled = true;\n            fn(arg);\n        };\n    };\n}\nfunction setToArray(itemSet) {\n    const output = [];\n    itemSet.forEach(value => {\n        output.push(value);\n    });\n    return output;\n}\nconst request = (options, callback) => {\n    if (options.protocol === 'https:') {\n        return https.request(options, callback);\n    }\n    else {\n        return http.request(options, callback);\n    }\n};\n/**\n *\n * The Pool maintains a list available Influx hosts and dispatches requests\n * to them. If there are errors connecting to hosts, it will disable that\n * host for a period of time.\n */\nexport class Pool {\n    /**\n     * Creates a new Pool instance.\n     * @param {IPoolOptions} options\n     */\n    constructor(options) {\n        this.options = Object.assign({\n            backoff: new ExponentialBackoff({\n                initial: 300,\n                max: 10 * 1000,\n                random: 1,\n            }),\n            maxRetries: 2,\n            requestTimeout: 30 * 1000,\n        }, options);\n        this.index = 0;\n        this.hostsAvailable = new Set();\n        this.hostsDisabled = new Set();\n        this.timeout = this.options.requestTimeout;\n    }\n    /**\n     * Returns a list of currently active hosts.\n     * @return {Host[]}\n     */\n    getHostsAvailable() {\n        return setToArray(this.hostsAvailable);\n    }\n    /**\n     * Returns a list of hosts that are currently disabled due to network\n     * errors.\n     * @return {Host[]}\n     */\n    getHostsDisabled() {\n        return setToArray(this.hostsDisabled);\n    }\n    /**\n     * Inserts a new host to the pool.\n     */\n    addHost(url) {\n        const host = new Host(url, this.options.backoff.reset());\n        this.hostsAvailable.add(host);\n        return host;\n    }\n    /**\n     * Returns true if there's any host available to by queried.\n     * @return {Boolean}\n     */\n    hostIsAvailable() {\n        return this.hostsAvailable.size > 0;\n    }\n    /**\n     * Makes a request and calls back with the response, parsed as JSON.\n     * An error is returned on a non-2xx status code or on a parsing exception.\n     */\n    json(options) {\n        return this.text(options).then(res => JSON.parse(res));\n    }\n    /**\n     * Makes a request and resolves with the plain text response,\n     * if possible. An error is raised on a non-2xx status code.\n     */\n    text(options) {\n        return new Promise((resolve, reject) => {\n            this.stream(options, (err, res) => {\n                if (err) {\n                    return reject(err);\n                }\n                let output = '';\n                res.on('data', str => output = output + str.toString());\n                res.on('end', () => resolve(output));\n            });\n        });\n    }\n    /**\n     * Makes a request and discards any response body it receives.\n     * An error is returned on a non-2xx status code.\n     */\n    discard(options) {\n        return new Promise((resolve, reject) => {\n            this.stream(options, (err, res) => {\n                if (err) {\n                    return reject(err);\n                }\n                res.on('data', () => { });\n                res.on('end', () => resolve());\n            });\n        });\n    }\n    /**\n     * Ping sends out a request to all available Influx servers, reporting on\n     * their response time and version number.\n     */\n    ping(timeout, path = '/ping') {\n        const todo = [];\n        setToArray(this.hostsAvailable)\n            .concat(setToArray(this.hostsDisabled))\n            .forEach(host => {\n            const start = Date.now();\n            const url = host.url;\n            const once = doOnce();\n            return todo.push(new Promise(resolve => {\n                const req = request({\n                    hostname: url.hostname,\n                    method: 'GET',\n                    path,\n                    port: Number(url.port),\n                    protocol: url.protocol,\n                    timeout,\n                }, once((res) => {\n                    resolve({\n                        url,\n                        res,\n                        online: res.statusCode < 300,\n                        rtt: Date.now() - start,\n                        version: res.headers['x-influxdb-version'],\n                    });\n                }));\n                const fail = once(() => {\n                    resolve({\n                        online: false,\n                        res: null,\n                        rtt: Infinity,\n                        url,\n                        version: null,\n                    });\n                });\n                // Support older Nodes and polyfills which don't allow .timeout() in\n                // the request options, wrapped in a conditional for even worse\n                // polyfills. See: https://github.com/node-influx/node-influx/issues/221\n                if (typeof req.setTimeout === 'function') {\n                    req.setTimeout(timeout, fail); // tslint:disable-line\n                }\n                req.on('timeout', fail);\n                req.on('error', fail);\n                req.end();\n            }));\n        });\n        return Promise.all(todo);\n    }\n    /**\n     * Makes a request and calls back with the IncomingMessage stream,\n     * if possible. An error is returned on a non-2xx status code.\n     */\n    stream(options, callback) {\n        if (!this.hostIsAvailable()) {\n            return callback(new ServiceNotAvailableError('No host available'), null);\n        }\n        let path = options.path;\n        if (options.query) {\n            path += '?' + querystring.stringify(options.query);\n        }\n        const once = doOnce();\n        const host = this.getHost();\n        const req = request({\n            headers: { 'content-length': options.body ? options.body.length : 0 },\n            hostname: host.url.hostname,\n            method: options.method,\n            path,\n            port: Number(host.url.port),\n            protocol: host.url.protocol,\n            timeout: this.timeout,\n        }, once((res) => {\n            if (res.statusCode >= 500) {\n                return this.handleRequestError(new ServiceNotAvailableError(res.statusMessage), host, options, callback);\n            }\n            if (res.statusCode >= 300) {\n                return RequestError.Create(req, res, err => callback(err, res));\n            }\n            host.success();\n            return callback(undefined, res);\n        }));\n        // Handle network or HTTP parsing errors:\n        req.on('error', once(err => {\n            this.handleRequestError(err, host, options, callback);\n        }));\n        // Handle timeouts:\n        req.on('timeout', once(() => {\n            this.handleRequestError(new ServiceNotAvailableError('Request timed out'), host, options, callback);\n        }));\n        // Support older Nodes and polyfills which don't allow .timeout() in the\n        // request options, wrapped in a conditional for even worse polyfills. See:\n        // https://github.com/node-influx/node-influx/issues/221\n        if (typeof req.setTimeout === 'function') {\n            req.setTimeout(this.timeout); // tslint:disable-line\n        }\n        // Write out the body:\n        if (options.body) {\n            req.write(options.body);\n        }\n        req.end();\n    }\n    /**\n     * Returns the next available host for querying.\n     * @return {Host}\n     */\n    getHost() {\n        const available = setToArray(this.hostsAvailable);\n        const host = available[this.index];\n        this.index = (this.index + 1) % available.length;\n        return host;\n    }\n    /**\n     * Re-enables the provided host, returning it to the pool to query.\n     * @param  {Host} host\n     */\n    enableHost(host) {\n        this.hostsDisabled.delete(host);\n        this.hostsAvailable.add(host);\n    }\n    /**\n     * Disables the provided host, removing it from the query pool. It will be\n     * re-enabled after a backoff interval\n     */\n    disableHost(host) {\n        this.hostsAvailable.delete(host);\n        this.hostsDisabled.add(host);\n        this.index %= Math.max(1, this.hostsAvailable.size);\n        setTimeout(() => this.enableHost(host), host.fail());\n    }\n    handleRequestError(err, host, options, callback) {\n        if (!(err instanceof ServiceNotAvailableError) &&\n            resubmitErrorCodes.indexOf(err.code) === -1) {\n            return callback(err, null);\n        }\n        this.disableHost(host);\n        const retries = options.retries || 0;\n        if (retries < this.options.maxRetries && this.hostIsAvailable()) {\n            options.retries = retries + 1;\n            return this.stream(options, callback);\n        }\n        callback(err, null);\n    }\n}\n",
    "importPath": "influx"
  },
  {
    "__docId__": 153,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "resubmitErrorCodes",
    "memberof": "src/pool.js",
    "longname": "src/pool.js~resubmitErrorCodes",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": "Status codes that will cause a host to be marked as 'failed' if we get\nthem from a request to Influx.",
    "lineNumber": 11,
    "type": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 154,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "ServiceNotAvailableError",
    "memberof": "src/pool.js",
    "longname": "src/pool.js~ServiceNotAvailableError",
    "access": null,
    "export": true,
    "importPath": "influx",
    "importStyle": "{ServiceNotAvailableError}",
    "description": "An ServiceNotAvailableError is returned as an error from requests that\nresult in a > 500 error code.",
    "lineNumber": 22,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 155,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/pool.js~ServiceNotAvailableError",
    "longname": "src/pool.js~ServiceNotAvailableError#constructor",
    "access": null,
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 156,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "message",
    "memberof": "src/pool.js~ServiceNotAvailableError",
    "longname": "src/pool.js~ServiceNotAvailableError#message",
    "access": null,
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 157,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "RequestError",
    "memberof": "src/pool.js",
    "longname": "src/pool.js~RequestError",
    "access": null,
    "export": true,
    "importPath": "influx",
    "importStyle": "{RequestError}",
    "description": "An RequestError is returned as an error from requests that\nresult in a 300 <= error code <= 500.",
    "lineNumber": 32,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 158,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/pool.js~RequestError",
    "longname": "src/pool.js~RequestError#constructor",
    "access": null,
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "params": [
      {
        "name": "req",
        "types": [
          "*"
        ]
      },
      {
        "name": "res",
        "types": [
          "*"
        ]
      },
      {
        "name": "body",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 159,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "req",
    "memberof": "src/pool.js~RequestError",
    "longname": "src/pool.js~RequestError#req",
    "access": null,
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 160,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "res",
    "memberof": "src/pool.js~RequestError",
    "longname": "src/pool.js~RequestError#res",
    "access": null,
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 161,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "message",
    "memberof": "src/pool.js~RequestError",
    "longname": "src/pool.js~RequestError#message",
    "access": null,
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 162,
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "Create",
    "memberof": "src/pool.js~RequestError",
    "longname": "src/pool.js~RequestError.Create",
    "access": null,
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "params": [
      {
        "name": "req",
        "types": [
          "*"
        ]
      },
      {
        "name": "res",
        "types": [
          "*"
        ]
      },
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 163,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "doOnce",
    "memberof": "src/pool.js",
    "longname": "src/pool.js~doOnce",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": "Creates a function generation that returns a wrapper which only allows\nthrough the first call of any function that it generated.",
    "lineNumber": 49,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 164,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "setToArray",
    "memberof": "src/pool.js",
    "longname": "src/pool.js~setToArray",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "params": [
      {
        "name": "itemSet",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 165,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "request",
    "memberof": "src/pool.js",
    "longname": "src/pool.js~request",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 166,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "Pool",
    "memberof": "src/pool.js",
    "longname": "src/pool.js~Pool",
    "access": null,
    "export": true,
    "importPath": "influx",
    "importStyle": "{Pool}",
    "description": "\nThe Pool maintains a list available Influx hosts and dispatches requests\nto them. If there are errors connecting to hosts, it will disable that\nhost for a period of time.",
    "lineNumber": 82,
    "interface": false
  },
  {
    "__docId__": 167,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#constructor",
    "access": null,
    "description": "Creates a new Pool instance.",
    "lineNumber": 87,
    "params": [
      {
        "nullable": null,
        "types": [
          "IPoolOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 168,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "options",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#options",
    "access": null,
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 169,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "index",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#index",
    "access": null,
    "description": null,
    "lineNumber": 97,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 170,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "hostsAvailable",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#hostsAvailable",
    "access": null,
    "description": null,
    "lineNumber": 98,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 171,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "hostsDisabled",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#hostsDisabled",
    "access": null,
    "description": null,
    "lineNumber": 99,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 172,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "timeout",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#timeout",
    "access": null,
    "description": null,
    "lineNumber": 100,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 173,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getHostsAvailable",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#getHostsAvailable",
    "access": null,
    "description": "Returns a list of currently active hosts.",
    "lineNumber": 106,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Host[]"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 174,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getHostsDisabled",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#getHostsDisabled",
    "access": null,
    "description": "Returns a list of hosts that are currently disabled due to network\nerrors.",
    "lineNumber": 114,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Host[]"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 175,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "addHost",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#addHost",
    "access": null,
    "description": "Inserts a new host to the pool.",
    "lineNumber": 120,
    "params": [
      {
        "name": "url",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 176,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "hostIsAvailable",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#hostIsAvailable",
    "access": null,
    "description": "Returns true if there's any host available to by queried.",
    "lineNumber": 129,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Boolean"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 177,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "json",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#json",
    "access": null,
    "description": "Makes a request and calls back with the response, parsed as JSON.\nAn error is returned on a non-2xx status code or on a parsing exception.",
    "lineNumber": 136,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 178,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "text",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#text",
    "access": null,
    "description": "Makes a request and resolves with the plain text response,\nif possible. An error is raised on a non-2xx status code.",
    "lineNumber": 143,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 179,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "discard",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#discard",
    "access": null,
    "description": "Makes a request and discards any response body it receives.\nAn error is returned on a non-2xx status code.",
    "lineNumber": 159,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 180,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "ping",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#ping",
    "access": null,
    "description": "Ping sends out a request to all available Influx servers, reporting on\ntheir response time and version number.",
    "lineNumber": 174,
    "params": [
      {
        "name": "timeout",
        "types": [
          "*"
        ]
      },
      {
        "name": "path",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "/ping",
        "defaultValue": "/ping"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 181,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "stream",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#stream",
    "access": null,
    "description": "Makes a request and calls back with the IncomingMessage stream,\nif possible. An error is returned on a non-2xx status code.",
    "lineNumber": 225,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 182,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getHost",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#getHost",
    "access": null,
    "description": "Returns the next available host for querying.",
    "lineNumber": 277,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Host"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 183,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "index",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#index",
    "access": null,
    "description": null,
    "lineNumber": 280,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 184,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "enableHost",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#enableHost",
    "access": null,
    "description": "Re-enables the provided host, returning it to the pool to query.",
    "lineNumber": 287,
    "params": [
      {
        "nullable": null,
        "types": [
          "Host"
        ],
        "spread": false,
        "optional": false,
        "name": "host",
        "description": ""
      }
    ],
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 185,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "disableHost",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#disableHost",
    "access": null,
    "description": "Disables the provided host, removing it from the query pool. It will be\nre-enabled after a backoff interval",
    "lineNumber": 295,
    "params": [
      {
        "name": "host",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 186,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "index",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#index",
    "access": null,
    "description": null,
    "lineNumber": 298,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 187,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "handleRequestError",
    "memberof": "src/pool.js~Pool",
    "longname": "src/pool.js~Pool#handleRequestError",
    "access": null,
    "description": null,
    "lineNumber": 301,
    "undocument": true,
    "params": [
      {
        "name": "err",
        "types": [
          "*"
        ]
      },
      {
        "name": "host",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      },
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 188,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/results.js",
    "memberof": null,
    "longname": "src/results.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import { isoOrTimeToDate } from './grammar';\n/**\n * A ResultError is thrown when a query generates errorful results from Influx.\n */\nexport class ResultError extends Error {\n    constructor(message) {\n        super();\n        this.message = `Error from InfluxDB: ${message}`;\n    }\n}\nfunction groupMethod(matcher) {\n    // We do a tiny bit of 'custom' deep equality checking here, taking\n    // advantage of the fact that the tag keys are consistent across all\n    // series results. This lets us match groupings much more efficiently,\n    // ~6000x faster than the fastest vanilla equality checker (lodash)\n    // when operating on large (~100,000 grouping) sets.\n    const srcKeys = this.groupsTagsKeys;\n    const dstKeys = Object.keys(matcher);\n    if (srcKeys.length === 0 || srcKeys.length !== dstKeys.length) {\n        return [];\n    }\n    L: for (let i = 0; i < this.groupRows.length; i += 1) {\n        for (let k = 0; k < srcKeys.length; k += 1) {\n            if (this.groupRows[i].tags[srcKeys[k]] !== matcher[srcKeys[k]]) {\n                continue L;\n            }\n        }\n        return this.groupRows[i].rows;\n    }\n    return [];\n}\nfunction groupsMethod() {\n    return this.groupRows;\n}\n/**\n * Inner parsing function which unpacks the series into a table and attaches\n * methods to the array. This is quite optimized and a bit of a mess to read,\n * but it's all fairly easy procedural logic.\n *\n * We do this instead of subclassing Array since subclassing has some\n * undesirable side-effects. For example, calling .slice() on the array\n * makes it impossible to preserve groups as would be necessary if it's\n * subclassed.\n */\nfunction parseInner(series = [], precision) {\n    const results = [];\n    const tags = results.groupsTagsKeys\n        = series.length && series[0].tags ? Object.keys(series[0].tags) : [];\n    let nextGroup = [];\n    results.groupRows = new Array(series.length); // tslint:disable-line\n    let lastEnd = 0;\n    for (let i = 0; i < series.length; i += 1, lastEnd = results.length) {\n        const { columns = [], values = [], } = series[i];\n        for (let k = 0; k < values.length; k += 1) {\n            const obj = {};\n            for (let j = 0; j < columns.length; j += 1) {\n                if (columns[j] === 'time') {\n                    obj.time = isoOrTimeToDate(values[k][j], precision);\n                }\n                else {\n                    obj[columns[j]] = values[k][j];\n                }\n            }\n            for (let j = 0; j < tags.length; j += 1) {\n                obj[tags[j]] = series[i].tags[tags[j]];\n            }\n            results.push(obj);\n            nextGroup.push(obj);\n        }\n        results.groupRows[i] = {\n            name: series[i].name,\n            rows: nextGroup,\n            tags: series[i].tags || {},\n        };\n        nextGroup = [];\n    }\n    results.group = groupMethod;\n    results.groups = groupsMethod;\n    return results;\n}\n/**\n * Checks if there are any errors in the IResponse and, if so, it throws them.\n * @private\n * @throws {ResultError}\n */\nexport function assertNoErrors(res) {\n    for (let i = 0; i < res.results.length; i += 1) {\n        const { error } = res.results[i];\n        if (error) {\n            throw new ResultError(error);\n        }\n    }\n    return res;\n}\n/**\n * From parses out a response to a result or list of responses.\n * There are three situations we cover here:\n *  1. A single query without groups, like `select * from myseries`\n *  2. A single query with groups, generated with a `group by` statement\n *     which groups by series *tags*, grouping by times is case (1)\n *  3. Multiple queries of types 1 and 2\n * @private\n */\nexport function parse(res, precision) {\n    assertNoErrors(res);\n    if (res.results.length === 1) {\n        return parseInner(res.results[0].series, precision);\n    }\n    else {\n        return res.results.map(result => parseInner(result.series, precision));\n    }\n}\n/**\n * parseSingle asserts that the response contains a single result,\n * and returns that result.\n * @throws {Error} if the number of results is not exactly one\n * @private\n */\nexport function parseSingle(res, precision) {\n    assertNoErrors(res);\n    if (res.results.length !== 1) {\n        throw new Error('node-influx expected the results length to equal 1, but ' +\n            `it was ${0}. Please report this here: https://git.io/influx-err`);\n    }\n    return parseInner(res.results[0].series, precision);\n}\n",
    "importPath": "influx"
  },
  {
    "__docId__": 189,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "ResultError",
    "memberof": "src/results.js",
    "longname": "src/results.js~ResultError",
    "access": null,
    "export": true,
    "importPath": "influx",
    "importStyle": "{ResultError}",
    "description": "A ResultError is thrown when a query generates errorful results from Influx.",
    "lineNumber": 5,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 190,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/results.js~ResultError",
    "longname": "src/results.js~ResultError#constructor",
    "access": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 191,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "message",
    "memberof": "src/results.js~ResultError",
    "longname": "src/results.js~ResultError#message",
    "access": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 192,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "groupMethod",
    "memberof": "src/results.js",
    "longname": "src/results.js~groupMethod",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "params": [
      {
        "name": "matcher",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 193,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "groupsMethod",
    "memberof": "src/results.js",
    "longname": "src/results.js~groupsMethod",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 194,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "parseInner",
    "memberof": "src/results.js",
    "longname": "src/results.js~parseInner",
    "access": null,
    "export": false,
    "importPath": "influx",
    "importStyle": null,
    "description": "Inner parsing function which unpacks the series into a table and attaches\nmethods to the array. This is quite optimized and a bit of a mess to read,\nbut it's all fairly easy procedural logic.\n\nWe do this instead of subclassing Array since subclassing has some\nundesirable side-effects. For example, calling .slice() on the array\nmakes it impossible to preserve groups as would be necessary if it's\nsubclassed.",
    "lineNumber": 45,
    "params": [
      {
        "name": "series",
        "optional": true,
        "types": [
          "*[]"
        ],
        "defaultRaw": [],
        "defaultValue": "[]"
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 195,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "assertNoErrors",
    "memberof": "src/results.js",
    "longname": "src/results.js~assertNoErrors",
    "access": "private",
    "export": true,
    "importPath": "influx",
    "importStyle": "{assertNoErrors}",
    "description": "Checks if there are any errors in the IResponse and, if so, it throws them.",
    "lineNumber": 86,
    "params": [
      {
        "name": "res",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "throws": [
      {
        "types": [
          "ResultError"
        ],
        "description": ""
      }
    ],
    "generator": false
  },
  {
    "__docId__": 196,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "parse",
    "memberof": "src/results.js",
    "longname": "src/results.js~parse",
    "access": "private",
    "export": true,
    "importPath": "influx",
    "importStyle": "{parse}",
    "description": "From parses out a response to a result or list of responses.\nThere are three situations we cover here:\n 1. A single query without groups, like `select * from myseries`\n 2. A single query with groups, generated with a `group by` statement\n    which groups by series *tags*, grouping by times is case (1)\n 3. Multiple queries of types 1 and 2",
    "lineNumber": 104,
    "params": [
      {
        "name": "res",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 197,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "parseSingle",
    "memberof": "src/results.js",
    "longname": "src/results.js~parseSingle",
    "access": "private",
    "export": true,
    "importPath": "influx",
    "importStyle": "{parseSingle}",
    "description": "parseSingle asserts that the response contains a single result,\nand returns that result.",
    "lineNumber": 119,
    "params": [
      {
        "name": "res",
        "types": [
          "*"
        ]
      },
      {
        "name": "precision",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if the number of results is not exactly one"
      }
    ],
    "generator": false
  },
  {
    "__docId__": 198,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/schema.js",
    "memberof": null,
    "longname": "src/schema.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import { escape, FieldType, isNumeric } from './grammar';\n/**\n * The Schema provides information and utilities for an InfluxDB measurement.\n * @private\n */\nexport class Schema {\n    constructor(options) {\n        this.options = options;\n        this.tagHash = {};\n        // fieldNames are sorted for performance: when coerceFields is run the\n        // fields will be added to the output in order.\n        this.fieldNames = Object.keys(options.fields).sort();\n        options.tags.forEach(tag => { this.tagHash[tag] = true; });\n    }\n    /**\n     * coerceFields converts a map of field values to a strings which\n     * can be injected into the line protocol without further escaping.\n     * The output is given in [key, value] pairs.\n     */\n    coerceFields(fields) {\n        let consumed = 0;\n        const output = [];\n        this.fieldNames.forEach(field => {\n            if (!fields.hasOwnProperty(field)) {\n                return;\n            }\n            const value = fields[field];\n            const typ = typeof value;\n            consumed += 1;\n            if (value == null) {\n                return;\n            }\n            let coerced;\n            switch (this.options.fields[field]) {\n                case FieldType.STRING:\n                    coerced = escape.quoted(String(value));\n                    break;\n                case FieldType.INTEGER:\n                    if (typ !== 'number' && !isNumeric(String(value))) {\n                        throw new Error(`Expected numeric value for ${this.ref(field)}, but got '${value}'!`);\n                    }\n                    coerced = String(Math.floor(value)) + 'i';\n                    break;\n                case FieldType.FLOAT:\n                    if (typ !== 'number' && !isNumeric(String(value))) {\n                        throw new Error(`Expected numeric value for ${this.ref(field)}, but got '${value}'!`);\n                    }\n                    coerced = String(value);\n                    break;\n                case FieldType.BOOLEAN:\n                    if (typ !== 'boolean') {\n                        throw new Error(`Expected boolean value for ${this.ref(field)}, but got a ${typ}!`);\n                    }\n                    coerced = value ? 'T' : 'F';\n                    break;\n                default:\n                    throw new Error(`Unknown field type ${this.options.fields[field]} for ${field} in ` +\n                        `${this.ref()}. Please ensure that your configuration is correct.`);\n            }\n            output.push([field, coerced]);\n        });\n        const keys = Object.keys(fields);\n        if (consumed !== keys.length) {\n            const extraneous = keys.filter(f => this.fieldNames.indexOf(f) === -1);\n            throw new Error(`Extraneous fields detected for writing InfluxDB point in` +\n                `${this.ref()}: \\`${extraneous.join('`, `')}\\`.`);\n        }\n        return output;\n    }\n    /**\n     * Throws an error if the tags include values other than\n     * what was specified in the schema. It returns a list of tag names.\n     */\n    checkTags(tags) {\n        const names = Object.keys(tags);\n        const extraneous = names.filter(tag => !this.tagHash[tag]);\n        if (extraneous.length > 0) {\n            throw new Error(`Extraneous tags detected for writing InfluxDB point in` +\n                `${this.ref()}: \\`${extraneous.join('`, `')}\\`.`);\n        }\n        return names;\n    }\n    /**\n     * Returns the 'db'.'measurement'[.'field'] referencing the current schema.\n     */\n    ref(field) {\n        let out = this.options.database + '.' + this.options.measurement;\n        if (field) {\n            out += '.' + field;\n        }\n        return out;\n    }\n}\n/**\n * Coerces the field map to a set of writable values, a la coerceFields,\n * using native guesses based on the field datatypes.\n * @private\n */\nexport function coerceBadly(fields) {\n    return Object.keys(fields).sort().map(field => {\n        const value = fields[field];\n        if (typeof value === 'string') {\n            return [field, escape.quoted(value)];\n        }\n        else {\n            return [field, String(value)];\n        }\n    });\n}\n",
    "importPath": "influx"
  },
  {
    "__docId__": 199,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "Schema",
    "memberof": "src/schema.js",
    "longname": "src/schema.js~Schema",
    "access": "private",
    "export": true,
    "importPath": "influx",
    "importStyle": "{Schema}",
    "description": "The Schema provides information and utilities for an InfluxDB measurement.",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 200,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/schema.js~Schema",
    "longname": "src/schema.js~Schema#constructor",
    "access": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 201,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "options",
    "memberof": "src/schema.js~Schema",
    "longname": "src/schema.js~Schema#options",
    "access": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 202,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "tagHash",
    "memberof": "src/schema.js~Schema",
    "longname": "src/schema.js~Schema#tagHash",
    "access": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 203,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "fieldNames",
    "memberof": "src/schema.js~Schema",
    "longname": "src/schema.js~Schema#fieldNames",
    "access": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "importPath": "influx"
  },
  {
    "__docId__": 204,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "coerceFields",
    "memberof": "src/schema.js~Schema",
    "longname": "src/schema.js~Schema#coerceFields",
    "access": null,
    "description": "coerceFields converts a map of field values to a strings which\ncan be injected into the line protocol without further escaping.\nThe output is given in [key, value] pairs.",
    "lineNumber": 20,
    "params": [
      {
        "name": "fields",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 205,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "checkTags",
    "memberof": "src/schema.js~Schema",
    "longname": "src/schema.js~Schema#checkTags",
    "access": null,
    "description": "Throws an error if the tags include values other than\nwhat was specified in the schema. It returns a list of tag names.",
    "lineNumber": 74,
    "params": [
      {
        "name": "tags",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 206,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "ref",
    "memberof": "src/schema.js~Schema",
    "longname": "src/schema.js~Schema#ref",
    "access": null,
    "description": "Returns the 'db'.'measurement'[.'field'] referencing the current schema.",
    "lineNumber": 86,
    "params": [
      {
        "name": "field",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false,
    "importPath": "influx"
  },
  {
    "__docId__": 207,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "coerceBadly",
    "memberof": "src/schema.js",
    "longname": "src/schema.js~coerceBadly",
    "access": "private",
    "export": true,
    "importPath": "influx",
    "importStyle": "{coerceBadly}",
    "description": "Coerces the field map to a set of writable values, a la coerceFields,\nusing native guesses based on the field datatypes.",
    "lineNumber": 99,
    "params": [
      {
        "name": "fields",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 209,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Infinity",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 210,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~NaN",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 211,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~undefined",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 212,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~null",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 213,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Object",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 214,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~object",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 215,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Function",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 216,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~function",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 217,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Boolean",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 218,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~boolean",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 219,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Symbol",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 220,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Error",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 221,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~EvalError",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 222,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~InternalError",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 223,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RangeError",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 224,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ReferenceError",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 225,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~SyntaxError",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 226,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~TypeError",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 227,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~URIError",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 228,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Number",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 229,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~number",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 230,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Date",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 231,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~String",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 232,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~string",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 233,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RegExp",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 234,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Array",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 235,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int8Array",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 236,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8Array",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 237,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8ClampedArray",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 238,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int16Array",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 239,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint16Array",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 240,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int32Array",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 241,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint32Array",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 242,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float32Array",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 243,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float64Array",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 244,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Map",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 245,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Set",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 246,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakMap",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 247,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakSet",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 248,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ArrayBuffer",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 249,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~DataView",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 250,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~JSON",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 251,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Promise",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 252,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Generator",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 253,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~GeneratorFunction",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 254,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Reflect",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 255,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Proxy",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 257,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "CanvasRenderingContext2D",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~CanvasRenderingContext2D",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 258,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "DocumentFragment",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~DocumentFragment",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 259,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Element",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Element",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Element",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 260,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Event",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Event",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Event",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 261,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Node",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Node",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Node",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 262,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "NodeList",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/NodeList",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~NodeList",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 263,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "XMLHttpRequest",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~XMLHttpRequest",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 264,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "AudioContext",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/AudioContext",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~AudioContext",
    "access": null,
    "description": "",
    "builtinExternal": true,
    "importPath": "influx"
  },
  {
    "__docId__": 265,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "unit/backoff.test.js",
    "memberof": null,
    "longname": "unit/backoff.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import { ExponentialBackoff } from '../../src/backoff/exponential';\nimport { expect } from 'chai';\ndescribe('backoff strategies', () => {\n    describe('exponential strategy', () => {\n        it('appears to work', () => {\n            let exp = new ExponentialBackoff({\n                initial: 500,\n                max: 5000,\n                random: 1,\n            });\n            function next() {\n                const value = exp.getDelay();\n                exp = exp.next();\n                return value;\n            }\n            const checkSequence = () => {\n                expect(next()).to.equal(500);\n                expect(next()).to.be.oneOf([500, 1000]);\n                expect(next()).to.be.oneOf([1000, 2000]);\n                expect(next()).to.be.oneOf([2000, 4000]);\n                expect(next()).to.be.oneOf([4000, 5000]);\n                expect(next()).to.equal(5000);\n            };\n            checkSequence();\n            exp = exp.reset();\n            const dupe = exp.reset();\n            checkSequence();\n            exp = dupe;\n            checkSequence();\n        });\n    });\n});\n",
    "importPath": "influx"
  },
  {
    "__docId__": 266,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe0",
    "testId": 0,
    "memberof": "unit/backoff.test.js",
    "testDepth": 0,
    "longname": "unit/backoff.test.js~describe0",
    "access": null,
    "description": "backoff strategies",
    "lineNumber": 3,
    "importPath": "influx"
  },
  {
    "__docId__": 267,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe1",
    "testId": 1,
    "memberof": "unit/backoff.test.js~describe0",
    "testDepth": 1,
    "longname": "unit/backoff.test.js~describe0.describe1",
    "access": null,
    "description": "exponential strategy",
    "lineNumber": 4,
    "importPath": "influx"
  },
  {
    "__docId__": 268,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it2",
    "testId": 2,
    "memberof": "unit/backoff.test.js~describe0.describe1",
    "testDepth": 2,
    "longname": "unit/backoff.test.js~describe0.describe1.it2",
    "access": null,
    "description": "appears to work",
    "lineNumber": 5,
    "importPath": "influx"
  },
  {
    "__docId__": 269,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "unit/builder.test.js",
    "memberof": null,
    "longname": "unit/builder.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import { Expression, Measurement, toNanoDate } from '../../src/index';\nimport { expect } from 'chai';\ndescribe('query builder', () => {\n    describe('measurement builder', () => {\n        it('builds with only name', () => {\n            expect(new Measurement()\n                .name('my_\"meas')\n                .toString()).to.equal('\"my_\\\\\"meas\"');\n        });\n        it('builds with name and rp', () => {\n            expect(new Measurement()\n                .name('my_\"meas')\n                .policy('po\"licy')\n                .toString()).to.equal('\"po\\\\\"licy\".\"my_\\\\\"meas\"');\n        });\n        it('builds with name, rp, and db', () => {\n            expect(new Measurement()\n                .name('my_\"meas')\n                .policy('po\"licy')\n                .db('my_\"db')\n                .toString()).to.equal('\"my_\\\\\"db\".\"po\\\\\"licy\".\"my_\\\\\"meas\"');\n        });\n        it('builds with name and db', () => {\n            expect(new Measurement()\n                .name('my_\"meas')\n                .db('my_\"db')\n                .toString()).to.equal('\"my_\\\\\"db\".\"my_\\\\\"meas\"');\n        });\n        it('throws when a name is omitted', () => {\n            expect(() => new Measurement()\n                .db('my_\"db')\n                .toString()).to.throw(/must specify a measurement/);\n        });\n    });\n    describe('expression builder', () => {\n        it('creates basic queries', () => {\n            expect(new Expression()\n                .tag('my_\"tag')\n                .equals\n                .value('42')\n                .toString()).to.equal('\"my_\\\\\"tag\" = \\'42\\'');\n        });\n        it('inserts data types correctly', () => {\n            expect(new Expression()\n                .field('f')\n                .equals\n                .value('str\\'')\n                .or\n                .field('f')\n                .matches\n                .value(/[0-9]+/)\n                .or\n                .field('f')\n                .equals\n                .value(42)\n                .or\n                .field('f')\n                .equals\n                .tag('my_\"tag')\n                .or\n                .field('f')\n                .equals\n                .value(new Date(1475985480231))\n                .or\n                .field('f')\n                .equals\n                .value(toNanoDate('1475985480231035600'))\n                .or\n                .field('f')\n                .equals\n                .value(true)\n                .or\n                .exp(e => e.field('a').equals.value(1).or.field('b').equals.value(2))\n                .or\n                .field('f')\n                .doesntMatch\n                .value({ toString: () => '/my-custom-re/' })\n                .toString()).to.equal('\"f\" = \\'str\\\\\\'\\' OR \"f\" =~ /[0-9]+/ OR \"f\" = 42 ' +\n                'OR \"f\" = \"my_\\\\\"tag\" OR \"f\" = \"2016-10-09 03:58:00.231\" ' +\n                'OR \"f\" = \"2016-10-09 03:58:00.231035600\" OR \"f\" = TRUE ' +\n                'OR (\"a\" = 1 OR \"b\" = 2) OR \"f\" !~ /my-custom-re/');\n        });\n        it('throws when using a flagged regex', () => {\n            expect(() => new Expression().field('f').matches.value(/a/i))\n                .to.throw(/doesn't support flags/);\n        });\n        it('throws when using un-stringifyable object', () => {\n            expect(() => new Expression().field('f').equals.value(Object.create(null)))\n                .to.throw(/doesn't know how to encode/);\n        });\n        const operationsTable = [\n            { method: 'equals', yields: '=' },\n            { method: 'notEqual', yields: '!=' },\n            { method: 'gt', yields: '>' },\n            { method: 'gte', yields: '>=' },\n            { method: 'lt', yields: '<' },\n            { method: 'lte', yields: '<=' },\n            { method: 'plus', yields: '+' },\n            { method: 'minus', yields: '-' },\n            { method: 'times', yields: '*' },\n            { method: 'div', yields: '/' },\n            { method: 'and', yields: 'AND' },\n            { method: 'or', yields: 'OR' },\n            { method: 'matches', yields: '=~' },\n            { method: 'doesntMatch', yields: '!~' },\n        ];\n        operationsTable.forEach(({ method, yields }) => {\n            it(`yields ${yields} from .${method}`, () => {\n                expect(new Expression().field('f')[method].value(true).toString())\n                    .to.equal(`\"f\" ${yields} TRUE`);\n            });\n        });\n    });\n});\n",
    "importPath": "influx"
  },
  {
    "__docId__": 270,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe3",
    "testId": 3,
    "memberof": "unit/builder.test.js",
    "testDepth": 0,
    "longname": "unit/builder.test.js~describe3",
    "access": null,
    "description": "query builder",
    "lineNumber": 3,
    "importPath": "influx"
  },
  {
    "__docId__": 271,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe4",
    "testId": 4,
    "memberof": "unit/builder.test.js~describe3",
    "testDepth": 1,
    "longname": "unit/builder.test.js~describe3.describe4",
    "access": null,
    "description": "measurement builder",
    "lineNumber": 4,
    "importPath": "influx"
  },
  {
    "__docId__": 272,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it5",
    "testId": 5,
    "memberof": "unit/builder.test.js~describe3.describe4",
    "testDepth": 2,
    "longname": "unit/builder.test.js~describe3.describe4.it5",
    "access": null,
    "description": "builds with only name",
    "lineNumber": 5,
    "importPath": "influx"
  },
  {
    "__docId__": 273,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it6",
    "testId": 6,
    "memberof": "unit/builder.test.js~describe3.describe4",
    "testDepth": 2,
    "longname": "unit/builder.test.js~describe3.describe4.it6",
    "access": null,
    "description": "builds with name and rp",
    "lineNumber": 10,
    "importPath": "influx"
  },
  {
    "__docId__": 274,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it7",
    "testId": 7,
    "memberof": "unit/builder.test.js~describe3.describe4",
    "testDepth": 2,
    "longname": "unit/builder.test.js~describe3.describe4.it7",
    "access": null,
    "description": "builds with name, rp, and db",
    "lineNumber": 16,
    "importPath": "influx"
  },
  {
    "__docId__": 275,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it8",
    "testId": 8,
    "memberof": "unit/builder.test.js~describe3.describe4",
    "testDepth": 2,
    "longname": "unit/builder.test.js~describe3.describe4.it8",
    "access": null,
    "description": "builds with name and db",
    "lineNumber": 23,
    "importPath": "influx"
  },
  {
    "__docId__": 276,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it9",
    "testId": 9,
    "memberof": "unit/builder.test.js~describe3.describe4",
    "testDepth": 2,
    "longname": "unit/builder.test.js~describe3.describe4.it9",
    "access": null,
    "description": "throws when a name is omitted",
    "lineNumber": 29,
    "importPath": "influx"
  },
  {
    "__docId__": 277,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe10",
    "testId": 10,
    "memberof": "unit/builder.test.js~describe3",
    "testDepth": 1,
    "longname": "unit/builder.test.js~describe3.describe10",
    "access": null,
    "description": "expression builder",
    "lineNumber": 35,
    "importPath": "influx"
  },
  {
    "__docId__": 278,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it11",
    "testId": 11,
    "memberof": "unit/builder.test.js~describe3.describe10",
    "testDepth": 2,
    "longname": "unit/builder.test.js~describe3.describe10.it11",
    "access": null,
    "description": "creates basic queries",
    "lineNumber": 36,
    "importPath": "influx"
  },
  {
    "__docId__": 279,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it12",
    "testId": 12,
    "memberof": "unit/builder.test.js~describe3.describe10",
    "testDepth": 2,
    "longname": "unit/builder.test.js~describe3.describe10.it12",
    "access": null,
    "description": "inserts data types correctly",
    "lineNumber": 43,
    "importPath": "influx"
  },
  {
    "__docId__": 280,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it13",
    "testId": 13,
    "memberof": "unit/builder.test.js~describe3.describe10",
    "testDepth": 2,
    "longname": "unit/builder.test.js~describe3.describe10.it13",
    "access": null,
    "description": "throws when using a flagged regex",
    "lineNumber": 83,
    "importPath": "influx"
  },
  {
    "__docId__": 281,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it14",
    "testId": 14,
    "memberof": "unit/builder.test.js~describe3.describe10",
    "testDepth": 2,
    "longname": "unit/builder.test.js~describe3.describe10.it14",
    "access": null,
    "description": "throws when using un-stringifyable object",
    "lineNumber": 87,
    "importPath": "influx"
  },
  {
    "__docId__": 282,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it15",
    "testId": 15,
    "memberof": "unit/builder.test.js~describe3.describe10",
    "testDepth": 2,
    "longname": "unit/builder.test.js~describe3.describe10.it15",
    "access": null,
    "lineNumber": 108,
    "importPath": "influx"
  },
  {
    "__docId__": 283,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "unit/grammar.test.js",
    "memberof": null,
    "longname": "unit/grammar.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import * as grammar from '../../src/grammar';\nimport { expect } from 'chai';\nconst escapeTables = require('../fixture/escapeTables.json');\ndescribe('grammar', () => {\n    Object.keys(escapeTables).forEach(escaper => {\n        describe(escaper, () => {\n            escapeTables[escaper].forEach(test => {\n                it(`escapes \\`${test[0]}\\` as \\`${test[1]}\\``, () => {\n                    expect(grammar.escape[escaper](test[0])).to.equal(test[1]);\n                });\n            });\n        });\n    });\n    it('does not escape raw values', () => {\n        expect(grammar.escape.quoted(new grammar.Raw('don\"t escape'))).to.equal('don\"t escape');\n    });\n    let nanoDate;\n    let milliDate;\n    beforeEach(() => {\n        nanoDate = grammar.isoOrTimeToDate('2016-10-09T03:58:00.231035677Z', 'n');\n        milliDate = new Date(1475985480231);\n    });\n    it('converts a nanoseconds timestamp to a nano date', () => {\n        const date = grammar.toNanoDate('1475985480231035600');\n        expect(date.getTime()).to.equal(1475985480231);\n        expect(date.getNanoTime()).to.equal('1475985480231035600'); // precision is lost\n        expect(date.toNanoISOString()).to.equal('2016-10-09T03:58:00.231035600Z');\n    });\n    describe('formatting', () => {\n        it('formats nanosecond dates', () => {\n            expect(grammar.formatDate(nanoDate)).to.equal('\"2016-10-09 03:58:00.231035677\"');\n        });\n        it('formats millisecond dates', () => {\n            expect(grammar.formatDate(milliDate)).to.equal('\"2016-10-09 03:58:00.231\"');\n        });\n    });\n    describe('parsing', () => {\n        it('parses ISO dates correctly', () => {\n            const parsed = grammar.isoOrTimeToDate('2016-10-09T03:58:00.231035677Z', 'n');\n            expect(parsed.getTime()).to.equal(1475985480231);\n            expect(parsed.getNanoTime()).to.equal('1475985480231035677');\n            expect(parsed.toNanoISOString()).to.equal('2016-10-09T03:58:00.231035677Z');\n        });\n        it('parses numeric `ns` timestamps', () => {\n            const parsed = grammar.isoOrTimeToDate(1475985480231035677, 'n');\n            expect(parsed.getTime()).to.equal(1475985480231);\n            expect(parsed.getNanoTime()).to.equal('1475985480231035600'); // precision is lost\n            expect(parsed.toNanoISOString()).to.equal('2016-10-09T03:58:00.231035600Z');\n        });\n        it('parses numeric `u` timestamps', () => {\n            const parsed = grammar.isoOrTimeToDate(1475985480231035, 'u');\n            expect(parsed.getTime()).to.equal(1475985480231);\n            expect(parsed.getNanoTime()).to.equal('1475985480231035000');\n            expect(parsed.toNanoISOString()).to.equal('2016-10-09T03:58:00.231035000Z');\n        });\n        it('parses numeric `ms` timestamps', () => {\n            const parsed = grammar.isoOrTimeToDate(1475985480231, 'ms');\n            expect(parsed.getTime()).to.equal(1475985480231);\n            expect(parsed.getNanoTime()).to.equal('1475985480231000000');\n        });\n        it('parses numeric `s` timestamps', () => {\n            const parsed = grammar.isoOrTimeToDate(1475985480, 's');\n            expect(parsed.getTime()).to.equal(1475985480000);\n            expect(parsed.getNanoTime()).to.equal('1475985480000000000');\n        });\n        it('parses numeric `m` timestamps', () => {\n            const parsed = grammar.isoOrTimeToDate(24599758, 'm');\n            expect(parsed.getTime()).to.equal(1475985480000);\n            expect(parsed.getNanoTime()).to.equal('1475985480000000000');\n        });\n        it('parses numeric `h` timestamps', () => {\n            const parsed = grammar.isoOrTimeToDate(409995, 'h');\n            expect(parsed.getTime()).to.equal(1475982000000);\n            expect(parsed.getNanoTime()).to.equal('1475982000000000000');\n        });\n    });\n    describe('timestamp casting', () => {\n        it('casts dates into timestamps', () => {\n            const d = new Date(1475121809084);\n            expect(grammar.castTimestamp(d, 'n')).to.equal('1475121809084000000');\n            expect(grammar.castTimestamp(d, 'u')).to.equal('1475121809084000');\n            expect(grammar.castTimestamp(d, 'ms')).to.equal('1475121809084');\n            expect(grammar.castTimestamp(d, 's')).to.equal('1475121809');\n            expect(grammar.castTimestamp(d, 'm')).to.equal('24585363');\n            expect(grammar.castTimestamp(d, 'h')).to.equal('409756');\n        });\n        it('casts nanodates into timestamps', () => {\n            const d = grammar.toNanoDate('1475985480231035600');\n            expect(grammar.castTimestamp(d, 'n')).to.equal('1475985480231035600');\n            expect(grammar.castTimestamp(d, 'u')).to.equal('1475985480231035');\n            expect(grammar.castTimestamp(d, 'ms')).to.equal('1475985480231');\n            expect(grammar.castTimestamp(d, 's')).to.equal('1475985480');\n            expect(grammar.castTimestamp(d, 'm')).to.equal('24599758');\n            expect(grammar.castTimestamp(d, 'h')).to.equal('409995');\n        });\n        it('accepts strings, numbers liternally', () => {\n            expect(grammar.castTimestamp('1475985480231035600', 's')).to.equal('1475985480231035600');\n            expect(grammar.castTimestamp(1475985480231, 's')).to.equal('1475985480231');\n        });\n        it('throws on non-numeric strings', () => {\n            expect(() => grammar.castTimestamp('wut', 's')).to.throw(/numeric value/);\n        });\n    });\n});\n",
    "importPath": "influx"
  },
  {
    "__docId__": 284,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe16",
    "testId": 16,
    "memberof": "unit/grammar.test.js",
    "testDepth": 0,
    "longname": "unit/grammar.test.js~describe16",
    "access": null,
    "description": "grammar",
    "lineNumber": 4,
    "importPath": "influx"
  },
  {
    "__docId__": 285,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe17",
    "testId": 17,
    "memberof": "unit/grammar.test.js~describe16",
    "testDepth": 1,
    "longname": "unit/grammar.test.js~describe16.describe17",
    "access": null,
    "lineNumber": 6,
    "importPath": "influx"
  },
  {
    "__docId__": 286,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it18",
    "testId": 18,
    "memberof": "unit/grammar.test.js~describe16.describe17",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe17.it18",
    "access": null,
    "lineNumber": 8,
    "importPath": "influx"
  },
  {
    "__docId__": 287,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it19",
    "testId": 19,
    "memberof": "unit/grammar.test.js~describe16",
    "testDepth": 1,
    "longname": "unit/grammar.test.js~describe16.it19",
    "access": null,
    "description": "does not escape raw values",
    "lineNumber": 14,
    "importPath": "influx"
  },
  {
    "__docId__": 288,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it20",
    "testId": 20,
    "memberof": "unit/grammar.test.js~describe16",
    "testDepth": 1,
    "longname": "unit/grammar.test.js~describe16.it20",
    "access": null,
    "description": "converts a nanoseconds timestamp to a nano date",
    "lineNumber": 23,
    "importPath": "influx"
  },
  {
    "__docId__": 289,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe21",
    "testId": 21,
    "memberof": "unit/grammar.test.js~describe16",
    "testDepth": 1,
    "longname": "unit/grammar.test.js~describe16.describe21",
    "access": null,
    "description": "formatting",
    "lineNumber": 29,
    "importPath": "influx"
  },
  {
    "__docId__": 290,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it22",
    "testId": 22,
    "memberof": "unit/grammar.test.js~describe16.describe21",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe21.it22",
    "access": null,
    "description": "formats nanosecond dates",
    "lineNumber": 30,
    "importPath": "influx"
  },
  {
    "__docId__": 291,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it23",
    "testId": 23,
    "memberof": "unit/grammar.test.js~describe16.describe21",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe21.it23",
    "access": null,
    "description": "formats millisecond dates",
    "lineNumber": 33,
    "importPath": "influx"
  },
  {
    "__docId__": 292,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe24",
    "testId": 24,
    "memberof": "unit/grammar.test.js~describe16",
    "testDepth": 1,
    "longname": "unit/grammar.test.js~describe16.describe24",
    "access": null,
    "description": "parsing",
    "lineNumber": 37,
    "importPath": "influx"
  },
  {
    "__docId__": 293,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it25",
    "testId": 25,
    "memberof": "unit/grammar.test.js~describe16.describe24",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe24.it25",
    "access": null,
    "description": "parses ISO dates correctly",
    "lineNumber": 38,
    "importPath": "influx"
  },
  {
    "__docId__": 294,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it26",
    "testId": 26,
    "memberof": "unit/grammar.test.js~describe16.describe24",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe24.it26",
    "access": null,
    "description": "parses numeric `ns` timestamps",
    "lineNumber": 44,
    "importPath": "influx"
  },
  {
    "__docId__": 295,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it27",
    "testId": 27,
    "memberof": "unit/grammar.test.js~describe16.describe24",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe24.it27",
    "access": null,
    "description": "parses numeric `u` timestamps",
    "lineNumber": 50,
    "importPath": "influx"
  },
  {
    "__docId__": 296,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it28",
    "testId": 28,
    "memberof": "unit/grammar.test.js~describe16.describe24",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe24.it28",
    "access": null,
    "description": "parses numeric `ms` timestamps",
    "lineNumber": 56,
    "importPath": "influx"
  },
  {
    "__docId__": 297,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it29",
    "testId": 29,
    "memberof": "unit/grammar.test.js~describe16.describe24",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe24.it29",
    "access": null,
    "description": "parses numeric `s` timestamps",
    "lineNumber": 61,
    "importPath": "influx"
  },
  {
    "__docId__": 298,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it30",
    "testId": 30,
    "memberof": "unit/grammar.test.js~describe16.describe24",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe24.it30",
    "access": null,
    "description": "parses numeric `m` timestamps",
    "lineNumber": 66,
    "importPath": "influx"
  },
  {
    "__docId__": 299,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it31",
    "testId": 31,
    "memberof": "unit/grammar.test.js~describe16.describe24",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe24.it31",
    "access": null,
    "description": "parses numeric `h` timestamps",
    "lineNumber": 71,
    "importPath": "influx"
  },
  {
    "__docId__": 300,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe32",
    "testId": 32,
    "memberof": "unit/grammar.test.js~describe16",
    "testDepth": 1,
    "longname": "unit/grammar.test.js~describe16.describe32",
    "access": null,
    "description": "timestamp casting",
    "lineNumber": 77,
    "importPath": "influx"
  },
  {
    "__docId__": 301,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it33",
    "testId": 33,
    "memberof": "unit/grammar.test.js~describe16.describe32",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe32.it33",
    "access": null,
    "description": "casts dates into timestamps",
    "lineNumber": 78,
    "importPath": "influx"
  },
  {
    "__docId__": 302,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it34",
    "testId": 34,
    "memberof": "unit/grammar.test.js~describe16.describe32",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe32.it34",
    "access": null,
    "description": "casts nanodates into timestamps",
    "lineNumber": 87,
    "importPath": "influx"
  },
  {
    "__docId__": 303,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it35",
    "testId": 35,
    "memberof": "unit/grammar.test.js~describe16.describe32",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe32.it35",
    "access": null,
    "description": "accepts strings, numbers liternally",
    "lineNumber": 96,
    "importPath": "influx"
  },
  {
    "__docId__": 304,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it36",
    "testId": 36,
    "memberof": "unit/grammar.test.js~describe16.describe32",
    "testDepth": 2,
    "longname": "unit/grammar.test.js~describe16.describe32.it36",
    "access": null,
    "description": "throws on non-numeric strings",
    "lineNumber": 100,
    "importPath": "influx"
  },
  {
    "__docId__": 305,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "unit/influx.test.js",
    "memberof": null,
    "longname": "unit/influx.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "'use strict';\nimport { FieldType, InfluxDB, toNanoDate } from '../../src';\nimport { dbFixture } from './helpers';\nimport { expect } from 'chai';\nconst sinon = require('sinon');\ndescribe('influxdb', () => {\n    describe('constructor', () => {\n        it('uses default options', () => {\n            expect((new InfluxDB()).options).to.deep.equal({\n                username: 'root',\n                password: 'root',\n                database: null,\n                pool: undefined,\n                schema: [],\n                hosts: [{\n                        host: '127.0.0.1',\n                        port: 8086,\n                        protocol: 'http',\n                    }],\n            });\n        });\n        it('parses dsns', () => {\n            expect((new InfluxDB('https://connor:password@192.168.0.1:1337/foo')).options).to.deep.equal({\n                username: 'connor',\n                password: 'password',\n                database: 'foo',\n                pool: undefined,\n                schema: [],\n                hosts: [{\n                        host: '192.168.0.1',\n                        port: 1337,\n                        protocol: 'https',\n                    }],\n            });\n        });\n        it('parses single configs', () => {\n            expect((new InfluxDB({ database: 'foo', host: '192.168.0.1' })).options).to.deep.equal({\n                username: 'root',\n                password: 'root',\n                database: 'foo',\n                pool: undefined,\n                schema: [],\n                hosts: [{\n                        host: '192.168.0.1',\n                        port: 8086,\n                        protocol: 'http',\n                    }],\n            });\n        });\n        it('parses cluster configs', () => {\n            expect((new InfluxDB({ database: 'foo', hosts: [{ host: '192.168.0.1' }] })).options).to.deep.equal({\n                username: 'root',\n                password: 'root',\n                database: 'foo',\n                schema: [],\n                hosts: [{\n                        host: '192.168.0.1',\n                        port: 8086,\n                        protocol: 'http',\n                    }],\n            });\n        });\n        it('parses parses schema', () => {\n            let client = (new InfluxDB({\n                schema: [{\n                        database: 'my_db',\n                        measurement: 'my_measurement',\n                        fields: {},\n                        tags: ['my_tag'],\n                    }],\n                hosts: [{ host: '192.168.0.1' }],\n            }));\n            expect(client.schema.my_db.my_measurement).to.not.be.undefined;\n            client = (new InfluxDB({\n                schema: [{\n                        measurement: 'my_measurement',\n                        fields: {},\n                        tags: ['my_tag'],\n                    }],\n                database: 'my_db',\n                hosts: [{ host: '192.168.0.1' }],\n            }));\n            expect(client.schema.my_db.my_measurement).to.not.be.undefined;\n            expect(() => {\n                new InfluxDB({\n                    schema: [{\n                            measurement: 'my_measurement',\n                            fields: {},\n                            tags: ['my_tag'],\n                        }],\n                    hosts: [{ host: '192.168.0.1' }],\n                });\n            }).to.throw(/no default database is provided/);\n        });\n    });\n    describe('methods', () => {\n        let influx;\n        let pool;\n        const expectations = [];\n        beforeEach(() => {\n            influx = new InfluxDB({\n                hosts: [],\n                schema: [\n                    {\n                        database: 'my_db',\n                        measurement: 'my_schemed_measure',\n                        tags: ['my_tag'],\n                        fields: {\n                            int: FieldType.INTEGER,\n                            float: FieldType.FLOAT,\n                            string: FieldType.STRING,\n                            bool: FieldType.BOOLEAN,\n                        },\n                    },\n                ],\n            });\n            pool = influx.pool;\n            sinon.stub(pool, 'discard');\n            sinon.stub(pool, 'json');\n            sinon.stub(pool, 'text');\n        });\n        afterEach(() => {\n            while (expectations.length) {\n                expectations.pop()();\n            }\n        });\n        const setDefaultDB = (db) => {\n            influx.options.database = db;\n        };\n        const expectQuery = (method, options, httpMethod = 'POST', yields = { results: [{}] }) => {\n            if (typeof options === 'string') {\n                options = { q: options };\n            }\n            pool[method].returns(Promise.resolve(yields));\n            expectations.push(() => {\n                expect(pool[method]).to.have.been.calledWith({\n                    method: httpMethod,\n                    path: '/query',\n                    query: Object.assign({\n                        u: 'root',\n                        p: 'root',\n                    }, options),\n                });\n            });\n        };\n        const expectWrite = (body, options) => {\n            if (typeof options === 'string') {\n                options = { q: options };\n            }\n            pool.discard.returns(Promise.resolve());\n            expectations.push(() => {\n                expect(pool.discard).to.have.been.calledWith({\n                    method: 'POST',\n                    path: '/write',\n                    body,\n                    query: Object.assign({\n                        u: 'root',\n                        p: 'root',\n                    }, options),\n                });\n            });\n        };\n        it('.createDatabase()', () => {\n            expectQuery('json', 'create database \"foo\"');\n            influx.createDatabase('foo');\n            expectQuery('json', 'create database \"f\\\\\"oo\"');\n            influx.createDatabase('f\"oo');\n        });\n        it('.dropDatabase()', () => {\n            expectQuery('json', 'drop database \"foo\"');\n            influx.dropDatabase('foo');\n            expectQuery('json', 'drop database \"f\\\\\"oo\"');\n            influx.dropDatabase('f\"oo');\n        });\n        it('.getDatabaseNames()', () => {\n            expectQuery('json', 'show databases', 'GET', dbFixture('showDatabases'));\n            return influx.getDatabaseNames().then(names => {\n                expect(names).to.deep.equal(['_internal', 'influx_test_gen']);\n            });\n        });\n        it('.getMeasurements()', () => {\n            setDefaultDB('mydb');\n            expectQuery('json', {\n                db: 'mydb',\n                q: 'show measurements',\n            }, 'GET', dbFixture('showMeasurements'));\n            return influx.getMeasurements().then(names => {\n                expect(names).to.deep.equal(['series_0', 'series_1', 'series_2']);\n            });\n        });\n        it('.getSeries() from all', () => {\n            setDefaultDB('mydb');\n            expectQuery('json', {\n                db: 'mydb',\n                q: 'show series',\n            }, 'GET', dbFixture('showSeries'));\n            return influx.getSeries().then(names => {\n                expect(names).to.deep.equal([\n                    'series_0,my_tag=0',\n                    'series_0,my_tag=1',\n                    'series_0,my_tag=5',\n                    'series_0,my_tag=6',\n                    'series_0,my_tag=7',\n                    'series_0,my_tag=8',\n                    'series_0,my_tag=9',\n                    'series_1,my_tag=0',\n                    'series_1,my_tag=2',\n                    'series_1,my_tag=4',\n                    'series_1,my_tag=5',\n                    'series_1,my_tag=6',\n                    'series_1,my_tag=7',\n                    'series_1,my_tag=8',\n                    'series_1,my_tag=9',\n                    'series_2,my_tag=1',\n                    'series_2,my_tag=2',\n                    'series_2,my_tag=3',\n                    'series_2,my_tag=4',\n                    'series_2,my_tag=5',\n                    'series_2,my_tag=6',\n                    'series_2,my_tag=7',\n                    'series_2,my_tag=8',\n                    'series_2,my_tag=9',\n                ]);\n            });\n        });\n        it('.getSeries() from single', () => {\n            expectQuery('json', {\n                db: 'mydb',\n                q: 'show series from \"measure_1\"',\n            }, 'GET', dbFixture('showSeriesFromOne'));\n            return influx.getSeries({\n                database: 'mydb',\n                measurement: 'measure_1',\n            }).then(names => {\n                expect(names).to.deep.equal([\n                    'series_1,my_tag=0',\n                    'series_1,my_tag=2',\n                    'series_1,my_tag=4',\n                    'series_1,my_tag=5',\n                    'series_1,my_tag=6',\n                    'series_1,my_tag=7',\n                    'series_1,my_tag=8',\n                    'series_1,my_tag=9',\n                ]);\n            });\n        });\n        it('.dropMeasurement()', () => {\n            expectQuery('json', {\n                db: 'my_db',\n                q: 'drop measurement \"series_1\"',\n            });\n            return influx.dropMeasurement('series_1', 'my_db');\n        });\n        describe('.dropSeries()', () => {\n            beforeEach(() => setDefaultDB('my_db'));\n            it('drops with only from clause by string', () => {\n                expectQuery('json', { db: 'my_db', q: 'drop series from \"series_0\"' });\n                influx.dropSeries({ measurement: '\"series_0\"' });\n            });\n            it('drops with only from clause by builder', () => {\n                expectQuery('json', { db: 'my_db', q: 'drop series from \"series_0\"' });\n                influx.dropSeries({ measurement: m => m.name('series_0') });\n            });\n            it('drops with only where clause by string', () => {\n                expectQuery('json', { db: 'my_db', q: 'drop series where \"my_tag\" = 1' });\n                influx.dropSeries({ where: '\"my_tag\" = 1' });\n            });\n            it('drops with only where clause by builder', () => {\n                expectQuery('json', { db: 'my_db', q: 'drop series where \"my_tag\" = 1' });\n                influx.dropSeries({ where: e => e.tag('my_tag').equals.value(1) });\n            });\n            it('drops with both', () => {\n                expectQuery('json', { db: 'my_db', q: 'drop series from \"series_0\" where \"my_tag\" = 1' });\n                influx.dropSeries({\n                    measurement: m => m.name('series_0'),\n                    where: e => e.tag('my_tag').equals.value(1),\n                });\n            });\n        });\n        it('.getUsers()', () => {\n            expectQuery('json', 'show users', 'GET', dbFixture('showUsers'));\n            return influx.getUsers().then(names => {\n                expect(names.slice()).to.deep.equal([\n                    { user: 'john', admin: true },\n                    { user: 'steve', admin: false },\n                ]);\n            });\n        });\n        describe('.createUser()', () => {\n            it('works with admin specified == true', () => {\n                expectQuery('json', 'create user \"con\\\\\"nor\" with password \\'pa55\\\\\\'word\\' with all privileges');\n                return influx.createUser('con\"nor', 'pa55\\'word', true);\n            });\n            it('works with admin specified == false', () => {\n                expectQuery('json', 'create user \"con\\\\\"nor\" with password \\'pa55\\\\\\'word\\'');\n                return influx.createUser('con\"nor', 'pa55\\'word', false);\n            });\n            it('works with admin unspecified', () => {\n                expectQuery('json', 'create user \"con\\\\\"nor\" with password \\'pa55\\\\\\'word\\'');\n                return influx.createUser('con\"nor', 'pa55\\'word');\n            });\n        });\n        describe('.grantPrivilege()', () => {\n            it('queries correctly', () => {\n                expectQuery('json', 'grant READ on \"my_\\\\\"_db\" to \"con\\\\\"nor\"');\n                return influx.grantPrivilege('con\"nor', 'READ', 'my_\"_db');\n            });\n            it('throws if DB unspecified', () => {\n                expect(() => influx.grantPrivilege('con\"nor', 'READ')).to.throw(/default database/);\n            });\n            it('fills in default DB', () => {\n                setDefaultDB('my_\\\\\"_db');\n                expectQuery('json', 'grant READ on \"my_\\\\\"_db\" to \"con\\\\\"nor\"');\n                return influx.grantPrivilege('con\"nor', 'READ', 'my_\"_db');\n            });\n        });\n        describe('.revokePrivilege()', () => {\n            it('queries correctly', () => {\n                expectQuery('json', 'revoke READ from \"con\\\\\"nor\" on \"my_\\\\\"_db\"');\n                return influx.revokePrivilege('con\"nor', 'READ', 'my_\"_db');\n            });\n            it('throws if DB unspecified', () => {\n                expect(() => influx.revokePrivilege('con\"nor', 'READ')).to.throw(/default database/);\n            });\n            it('fills in default DB', () => {\n                setDefaultDB('my_\\\\\"_db');\n                expectQuery('json', 'revoke READ from \"con\\\\\"nor\" on \"my_\\\\\"_db\"');\n                return influx.revokePrivilege('con\"nor', 'READ', 'my_\"_db');\n            });\n        });\n        it('.grantAdminPrivilege()', () => {\n            expectQuery('json', 'grant all to \"con\\\\\"nor\"');\n            return influx.grantAdminPrivilege('con\"nor');\n        });\n        it('.revokeAdminPrivilege()', () => {\n            expectQuery('json', 'revoke all from \"con\\\\\"nor\"');\n            return influx.revokeAdminPrivilege('con\"nor');\n        });\n        it('.dropUser()', () => {\n            expectQuery('json', 'drop user \"con\\\\\"nor\"');\n            return influx.dropUser('con\"nor');\n        });\n        describe('.createContinuousQuery()', () => {\n            it('queries correctly', () => {\n                expectQuery('json', 'create continuous query \"my_\\\\\"q\" on \"my_\\\\\"_db\" begin foo end');\n                return influx.createContinuousQuery('my_\"q', 'foo', 'my_\"_db');\n            });\n            it('throws if DB unspecified', () => {\n                expect(() => influx.createContinuousQuery('my_\"q', 'foo')).to.throw(/default database/);\n            });\n            it('fills in default DB', () => {\n                setDefaultDB('my_\"_db');\n                expectQuery('json', 'create continuous query \"my_\\\\\"q\" on \"my_\\\\\"_db\" begin foo end');\n                return influx.createContinuousQuery('my_\"q', 'foo');\n            });\n        });\n        describe('.dropContinuousQuery()', () => {\n            it('queries correctly', () => {\n                expectQuery('json', 'drop continuous query \"my_\\\\\"q\" on \"my_\\\\\"_db\"');\n                return influx.dropContinuousQuery('my_\"q', 'my_\"_db');\n            });\n            it('throws if DB unspecified', () => {\n                expect(() => influx.dropContinuousQuery('my_\"q')).to.throw(/default database/);\n            });\n            it('fills in default DB', () => {\n                setDefaultDB('my_\"_db');\n                expectQuery('json', 'drop continuous query \"my_\\\\\"q\" on \"my_\\\\\"_db\"');\n                return influx.dropContinuousQuery('my_\"q');\n            });\n        });\n        describe('.showContinousQueries()', () => {\n            it('queries correctly', () => {\n                expectQuery('json', { q: 'show continuous queries', db: 'my_db' }, 'GET');\n                return influx.showContinousQueries('my_db');\n            });\n            it('throws if DB unspecified', () => {\n                expect(() => influx.showContinousQueries()).to.throw(/default database/);\n            });\n            it('fills in default DB', () => {\n                setDefaultDB('my_db');\n                expectQuery('json', { q: 'show continuous queries', db: 'my_db' }, 'GET');\n                return influx.showContinousQueries();\n            });\n        });\n        describe('.writePoints()', () => {\n            it('writes with all options specified without a schema', () => {\n                expectWrite('mymeas,my_tag=1 myfield=90 1463683075', {\n                    precision: 's',\n                    rp: '1day',\n                    db: 'my_db',\n                });\n                return influx.writePoints([\n                    {\n                        measurement: 'mymeas',\n                        tags: { my_tag: '1' },\n                        fields: { myfield: 90 },\n                        timestamp: new Date(1463683075000),\n                    },\n                ], {\n                    database: 'my_db',\n                    precision: 's',\n                    retentionPolicy: '1day',\n                });\n            });\n            it('writes using default options without a schema', () => {\n                setDefaultDB('my_db');\n                expectWrite('mymeas,my_tag=1 myfield=90 1463683075000000000', {\n                    precision: 'n',\n                    rp: undefined,\n                    db: 'my_db',\n                });\n                return influx.writePoints([\n                    {\n                        measurement: 'mymeas',\n                        tags: { my_tag: '1' },\n                        fields: { myfield: 90 },\n                        timestamp: new Date(1463683075000),\n                    },\n                ]);\n            });\n            it('uses a schema to coerce', () => {\n                setDefaultDB('my_db');\n                expectWrite('my_schemed_measure,my_tag=1 bool=T,float=43,int=42i', {\n                    precision: 'n',\n                    rp: undefined,\n                    db: 'my_db',\n                });\n                return influx.writePoints([\n                    {\n                        measurement: 'my_schemed_measure',\n                        tags: { my_tag: '1' },\n                        fields: {\n                            int: 42,\n                            float: 43,\n                            bool: true,\n                        },\n                    },\n                ]);\n            });\n            it('throws on schema violations', () => {\n                setDefaultDB('my_db');\n                expect(() => {\n                    influx.writePoints([\n                        {\n                            measurement: 'my_schemed_measure',\n                            tags: { not_a_tag: '1' },\n                        },\n                    ]);\n                }).to.throw(/extraneous tags/i);\n                expect(() => {\n                    influx.writePoints([\n                        {\n                            measurement: 'my_schemed_measure',\n                            fields: { not_a_field: '1' },\n                        },\n                    ]);\n                }).to.throw(/extraneous fields/i);\n                expect(() => {\n                    influx.writePoints([\n                        {\n                            measurement: 'my_schemed_measure',\n                            fields: { bool: 'lol, not a bool' },\n                        },\n                    ]);\n                }).to.throw(/expected bool/i);\n            });\n            it('handles lack of tags', () => {\n                expectWrite('mymeas myfield=90', {\n                    precision: 'n',\n                    rp: undefined,\n                    db: 'my_db',\n                });\n                return influx.writePoints([\n                    {\n                        measurement: 'mymeas',\n                        fields: { myfield: 90 },\n                    },\n                ], { database: 'my_db' });\n            });\n            it('handles lack of fields', () => {\n                expectWrite('mymeas,my_tag=90', {\n                    precision: 'n',\n                    rp: undefined,\n                    db: 'my_db',\n                });\n                return influx.writePoints([\n                    {\n                        measurement: 'mymeas',\n                        tags: { my_tag: 90 },\n                    },\n                ], { database: 'my_db' });\n            });\n            it('handles multiple tags', () => {\n                expectWrite('mymeas,my_tag1=90,my_tag2=45', {\n                    precision: 'n',\n                    rp: undefined,\n                    db: 'my_db',\n                });\n                return influx.writePoints([\n                    {\n                        measurement: 'mymeas',\n                        tags: { my_tag1: 90, my_tag2: 45 },\n                    },\n                ], { database: 'my_db' });\n            });\n            it('writes with the .writeMeasurement method', () => {\n                setDefaultDB('my_db');\n                expectWrite('mymeas,my_tag=1 myfield=90 1463683075000000000', {\n                    precision: 'n',\n                    rp: undefined,\n                    db: 'my_db',\n                });\n                return influx.writeMeasurement('mymeas', [\n                    {\n                        tags: { my_tag: '1' },\n                        fields: { myfield: 90 },\n                        timestamp: new Date(1463683075000),\n                    },\n                ]);\n            });\n            it('accepts nanoseconds (as ms)', () => {\n                setDefaultDB('my_db');\n                expectWrite('mymeas,my_tag=1 myfield=90 1463683075000000000', {\n                    precision: 'n',\n                    rp: undefined,\n                    db: 'my_db',\n                });\n                return influx.writeMeasurement('mymeas', [\n                    {\n                        tags: { my_tag: '1' },\n                        fields: { myfield: 90 },\n                        timestamp: toNanoDate('1463683075000000000'),\n                    },\n                ]);\n            });\n            it('accepts timestamp overriding', () => {\n                setDefaultDB('my_db');\n                expectWrite('mymeas,my_tag=1 myfield=90 1463683075000', {\n                    precision: 'ms',\n                    rp: undefined,\n                    db: 'my_db',\n                });\n                return influx.writeMeasurement('mymeas', [\n                    {\n                        tags: { my_tag: '1' },\n                        fields: { myfield: 90 },\n                        timestamp: toNanoDate('1463683075000000000'),\n                    },\n                ], { precision: 'ms' });\n            });\n        });\n        describe('.query', () => {\n            beforeEach(() => setDefaultDB('my_db'));\n            it('runs raw queries', () => {\n                expectQuery('json', {\n                    q: 'select * from series_0',\n                    epoch: undefined,\n                    rp: undefined,\n                    db: 'my_db',\n                }, 'GET', dbFixture('selectFromOne'));\n                return influx.queryRaw('select * from series_0').then(res => {\n                    expect(res).to.deep.equal(dbFixture('selectFromOne'));\n                });\n            });\n            it('parses query output', () => {\n                expectQuery('json', {\n                    q: 'select * from series_0',\n                    epoch: undefined,\n                    rp: undefined,\n                    db: 'my_db',\n                }, 'GET', dbFixture('selectFromOne'));\n                return influx.query('select * from series_0').then(res => {\n                    expect(res.slice()).to.deep.equal([\n                        { time: new Date('2016-09-29T02:19:09.38Z'), my_tag: '1', my_value: 67 },\n                        { time: new Date('2016-09-29T02:19:09.379Z'), my_tag: '1', my_value: 32 },\n                    ]);\n                });\n            });\n            it('selects from multiple', () => {\n                expectQuery('json', {\n                    q: 'select * from series_0;select * from series_1',\n                    epoch: undefined,\n                    rp: undefined,\n                    db: 'my_db',\n                }, 'GET', dbFixture('selectFromOne'));\n                return influx.query(['select * from series_0', 'select * from series_1']);\n            });\n            it('passes in options', () => {\n                expectQuery('json', {\n                    q: 'select * from series_0',\n                    epoch: 'ms',\n                    rp: 'asdf',\n                    db: 'my_db',\n                }, 'GET', dbFixture('selectFromOne'));\n                return influx.query(['select * from series_0'], {\n                    precision: 'ms',\n                    retentionPolicy: 'asdf',\n                });\n            });\n            it('rewrites nanosecond precisions', () => {\n                expectQuery('json', {\n                    q: 'select * from series_0',\n                    epoch: undefined,\n                    rp: 'asdf',\n                    db: 'my_db',\n                }, 'GET', dbFixture('selectFromOne'));\n                return influx.query(['select * from series_0'], {\n                    precision: 'n',\n                    retentionPolicy: 'asdf',\n                });\n            });\n        });\n        describe('.createRetentionPolicy', () => {\n            beforeEach(() => setDefaultDB('my_db'));\n            it('creates non-default policies', () => {\n                expectQuery('json', 'create retention policy \"7d\\\\\"\" on \"test\" ' +\n                    'duration 7d replication 1');\n                return influx.createRetentionPolicy('7d\"', {\n                    database: 'test',\n                    duration: '7d',\n                    replication: 1,\n                });\n            });\n            it('creates default policies', () => {\n                expectQuery('json', 'create retention policy \"7d\\\\\"\" on \"my_db\" ' +\n                    'duration 7d replication 1 default');\n                return influx.createRetentionPolicy('7d\"', {\n                    duration: '7d',\n                    replication: 1,\n                    isDefault: true,\n                });\n            });\n        });\n        describe('.alterRetentionPolicy', () => {\n            beforeEach(() => setDefaultDB('my_db'));\n            it('creates non-default policies', () => {\n                expectQuery('json', 'alter retention policy \"7d\\\\\"\" on \"test\" ' +\n                    'duration 7d replication 1');\n                return influx.alterRetentionPolicy('7d\"', {\n                    database: 'test',\n                    duration: '7d',\n                    replication: 1,\n                });\n            });\n            it('creates default policies', () => {\n                expectQuery('json', 'alter retention policy \"7d\\\\\"\" on \"my_db\" ' +\n                    'duration 7d replication 1 default');\n                return influx.alterRetentionPolicy('7d\"', {\n                    duration: '7d',\n                    replication: 1,\n                    isDefault: true,\n                });\n            });\n        });\n        it('drops retention policies', () => {\n            setDefaultDB('my_db');\n            expectQuery('json', 'drop retention policy \"7d\\\\\"\" on \"my_db\"');\n            return influx.dropRetentionPolicy('7d\"');\n        });\n        it('shows retention policies', () => {\n            const data = dbFixture('showRetentionPolicies');\n            expectQuery('json', 'show retention policies on \"my\\\\\"db\"', 'GET', data);\n            influx.showRetentionPolicies('my\"db');\n            setDefaultDB('my_db');\n            expectQuery('json', 'show retention policies on \"my_db\"', 'GET', data);\n            return influx.showRetentionPolicies().then(res => {\n                expect(res.slice()).to.deep.equal([\n                    {\n                        name: 'autogen',\n                        duration: '0s',\n                        shardGroupDuration: '168h0m0s',\n                        replicaN: 1,\n                        default: true,\n                    },\n                    {\n                        name: '7d',\n                        duration: '168h0m0s',\n                        shardGroupDuration: '24h0m0s',\n                        replicaN: 1,\n                        default: false,\n                    },\n                ]);\n            });\n        });\n    });\n});\n",
    "importPath": "influx"
  },
  {
    "__docId__": 306,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe37",
    "testId": 37,
    "memberof": "unit/influx.test.js",
    "testDepth": 0,
    "longname": "unit/influx.test.js~describe37",
    "access": null,
    "description": "influxdb",
    "lineNumber": 6,
    "importPath": "influx"
  },
  {
    "__docId__": 307,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe38",
    "testId": 38,
    "memberof": "unit/influx.test.js~describe37",
    "testDepth": 1,
    "longname": "unit/influx.test.js~describe37.describe38",
    "access": null,
    "description": "constructor",
    "lineNumber": 7,
    "importPath": "influx"
  },
  {
    "__docId__": 308,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it39",
    "testId": 39,
    "memberof": "unit/influx.test.js~describe37.describe38",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe38.it39",
    "access": null,
    "description": "uses default options",
    "lineNumber": 8,
    "importPath": "influx"
  },
  {
    "__docId__": 309,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it40",
    "testId": 40,
    "memberof": "unit/influx.test.js~describe37.describe38",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe38.it40",
    "access": null,
    "description": "parses dsns",
    "lineNumber": 22,
    "importPath": "influx"
  },
  {
    "__docId__": 310,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it41",
    "testId": 41,
    "memberof": "unit/influx.test.js~describe37.describe38",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe38.it41",
    "access": null,
    "description": "parses single configs",
    "lineNumber": 36,
    "importPath": "influx"
  },
  {
    "__docId__": 311,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it42",
    "testId": 42,
    "memberof": "unit/influx.test.js~describe37.describe38",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe38.it42",
    "access": null,
    "description": "parses cluster configs",
    "lineNumber": 50,
    "importPath": "influx"
  },
  {
    "__docId__": 312,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it43",
    "testId": 43,
    "memberof": "unit/influx.test.js~describe37.describe38",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe38.it43",
    "access": null,
    "description": "parses parses schema",
    "lineNumber": 63,
    "importPath": "influx"
  },
  {
    "__docId__": 313,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe44",
    "testId": 44,
    "memberof": "unit/influx.test.js~describe37",
    "testDepth": 1,
    "longname": "unit/influx.test.js~describe37.describe44",
    "access": null,
    "description": "methods",
    "lineNumber": 96,
    "importPath": "influx"
  },
  {
    "__docId__": 314,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it45",
    "testId": 45,
    "memberof": "unit/influx.test.js~describe37.describe44",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe44.it45",
    "access": null,
    "description": ".createDatabase()",
    "lineNumber": 163,
    "importPath": "influx"
  },
  {
    "__docId__": 315,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it46",
    "testId": 46,
    "memberof": "unit/influx.test.js~describe37.describe44",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe44.it46",
    "access": null,
    "description": ".dropDatabase()",
    "lineNumber": 169,
    "importPath": "influx"
  },
  {
    "__docId__": 316,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it47",
    "testId": 47,
    "memberof": "unit/influx.test.js~describe37.describe44",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe44.it47",
    "access": null,
    "description": ".getDatabaseNames()",
    "lineNumber": 175,
    "importPath": "influx"
  },
  {
    "__docId__": 317,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it48",
    "testId": 48,
    "memberof": "unit/influx.test.js~describe37.describe44",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe44.it48",
    "access": null,
    "description": ".getMeasurements()",
    "lineNumber": 181,
    "importPath": "influx"
  },
  {
    "__docId__": 318,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it49",
    "testId": 49,
    "memberof": "unit/influx.test.js~describe37.describe44",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe44.it49",
    "access": null,
    "description": ".getSeries() from all",
    "lineNumber": 191,
    "importPath": "influx"
  },
  {
    "__docId__": 319,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it50",
    "testId": 50,
    "memberof": "unit/influx.test.js~describe37.describe44",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe44.it50",
    "access": null,
    "description": ".getSeries() from single",
    "lineNumber": 226,
    "importPath": "influx"
  },
  {
    "__docId__": 320,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it51",
    "testId": 51,
    "memberof": "unit/influx.test.js~describe37.describe44",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe44.it51",
    "access": null,
    "description": ".dropMeasurement()",
    "lineNumber": 247,
    "importPath": "influx"
  },
  {
    "__docId__": 321,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe52",
    "testId": 52,
    "memberof": "unit/influx.test.js~describe37.describe44",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe44.describe52",
    "access": null,
    "description": ".dropSeries()",
    "lineNumber": 254,
    "importPath": "influx"
  },
  {
    "__docId__": 322,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it53",
    "testId": 53,
    "memberof": "unit/influx.test.js~describe37.describe44.describe52",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe52.it53",
    "access": null,
    "description": "drops with only from clause by string",
    "lineNumber": 256,
    "importPath": "influx"
  },
  {
    "__docId__": 323,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it54",
    "testId": 54,
    "memberof": "unit/influx.test.js~describe37.describe44.describe52",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe52.it54",
    "access": null,
    "description": "drops with only from clause by builder",
    "lineNumber": 260,
    "importPath": "influx"
  },
  {
    "__docId__": 324,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it55",
    "testId": 55,
    "memberof": "unit/influx.test.js~describe37.describe44.describe52",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe52.it55",
    "access": null,
    "description": "drops with only where clause by string",
    "lineNumber": 264,
    "importPath": "influx"
  },
  {
    "__docId__": 325,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it56",
    "testId": 56,
    "memberof": "unit/influx.test.js~describe37.describe44.describe52",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe52.it56",
    "access": null,
    "description": "drops with only where clause by builder",
    "lineNumber": 268,
    "importPath": "influx"
  },
  {
    "__docId__": 326,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it57",
    "testId": 57,
    "memberof": "unit/influx.test.js~describe37.describe44.describe52",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe52.it57",
    "access": null,
    "description": "drops with both",
    "lineNumber": 272,
    "importPath": "influx"
  },
  {
    "__docId__": 327,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it58",
    "testId": 58,
    "memberof": "unit/influx.test.js~describe37.describe44",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe44.it58",
    "access": null,
    "description": ".getUsers()",
    "lineNumber": 280,
    "importPath": "influx"
  },
  {
    "__docId__": 328,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe59",
    "testId": 59,
    "memberof": "unit/influx.test.js~describe37.describe44",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe44.describe59",
    "access": null,
    "description": ".createUser()",
    "lineNumber": 289,
    "importPath": "influx"
  },
  {
    "__docId__": 329,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it60",
    "testId": 60,
    "memberof": "unit/influx.test.js~describe37.describe44.describe59",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe59.it60",
    "access": null,
    "description": "works with admin specified == true",
    "lineNumber": 290,
    "importPath": "influx"
  },
  {
    "__docId__": 330,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it61",
    "testId": 61,
    "memberof": "unit/influx.test.js~describe37.describe44.describe59",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe59.it61",
    "access": null,
    "description": "works with admin specified == false",
    "lineNumber": 294,
    "importPath": "influx"
  },
  {
    "__docId__": 331,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it62",
    "testId": 62,
    "memberof": "unit/influx.test.js~describe37.describe44.describe59",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe59.it62",
    "access": null,
    "description": "works with admin unspecified",
    "lineNumber": 298,
    "importPath": "influx"
  },
  {
    "__docId__": 332,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe63",
    "testId": 63,
    "memberof": "unit/influx.test.js~describe37.describe44",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe44.describe63",
    "access": null,
    "description": ".grantPrivilege()",
    "lineNumber": 303,
    "importPath": "influx"
  },
  {
    "__docId__": 333,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it64",
    "testId": 64,
    "memberof": "unit/influx.test.js~describe37.describe44.describe63",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe63.it64",
    "access": null,
    "description": "queries correctly",
    "lineNumber": 304,
    "importPath": "influx"
  },
  {
    "__docId__": 334,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it65",
    "testId": 65,
    "memberof": "unit/influx.test.js~describe37.describe44.describe63",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe63.it65",
    "access": null,
    "description": "throws if DB unspecified",
    "lineNumber": 308,
    "importPath": "influx"
  },
  {
    "__docId__": 335,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it66",
    "testId": 66,
    "memberof": "unit/influx.test.js~describe37.describe44.describe63",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe63.it66",
    "access": null,
    "description": "fills in default DB",
    "lineNumber": 311,
    "importPath": "influx"
  },
  {
    "__docId__": 336,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe67",
    "testId": 67,
    "memberof": "unit/influx.test.js~describe37.describe44",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe44.describe67",
    "access": null,
    "description": ".revokePrivilege()",
    "lineNumber": 317,
    "importPath": "influx"
  },
  {
    "__docId__": 337,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it68",
    "testId": 68,
    "memberof": "unit/influx.test.js~describe37.describe44.describe67",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe67.it68",
    "access": null,
    "description": "queries correctly",
    "lineNumber": 318,
    "importPath": "influx"
  },
  {
    "__docId__": 338,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it69",
    "testId": 69,
    "memberof": "unit/influx.test.js~describe37.describe44.describe67",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe67.it69",
    "access": null,
    "description": "throws if DB unspecified",
    "lineNumber": 322,
    "importPath": "influx"
  },
  {
    "__docId__": 339,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it70",
    "testId": 70,
    "memberof": "unit/influx.test.js~describe37.describe44.describe67",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe67.it70",
    "access": null,
    "description": "fills in default DB",
    "lineNumber": 325,
    "importPath": "influx"
  },
  {
    "__docId__": 340,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it71",
    "testId": 71,
    "memberof": "unit/influx.test.js~describe37.describe44",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe44.it71",
    "access": null,
    "description": ".grantAdminPrivilege()",
    "lineNumber": 331,
    "importPath": "influx"
  },
  {
    "__docId__": 341,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it72",
    "testId": 72,
    "memberof": "unit/influx.test.js~describe37.describe44",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe44.it72",
    "access": null,
    "description": ".revokeAdminPrivilege()",
    "lineNumber": 335,
    "importPath": "influx"
  },
  {
    "__docId__": 342,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it73",
    "testId": 73,
    "memberof": "unit/influx.test.js~describe37.describe44",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe44.it73",
    "access": null,
    "description": ".dropUser()",
    "lineNumber": 339,
    "importPath": "influx"
  },
  {
    "__docId__": 343,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe74",
    "testId": 74,
    "memberof": "unit/influx.test.js~describe37.describe44",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe44.describe74",
    "access": null,
    "description": ".createContinuousQuery()",
    "lineNumber": 343,
    "importPath": "influx"
  },
  {
    "__docId__": 344,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it75",
    "testId": 75,
    "memberof": "unit/influx.test.js~describe37.describe44.describe74",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe74.it75",
    "access": null,
    "description": "queries correctly",
    "lineNumber": 344,
    "importPath": "influx"
  },
  {
    "__docId__": 345,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it76",
    "testId": 76,
    "memberof": "unit/influx.test.js~describe37.describe44.describe74",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe74.it76",
    "access": null,
    "description": "throws if DB unspecified",
    "lineNumber": 348,
    "importPath": "influx"
  },
  {
    "__docId__": 346,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it77",
    "testId": 77,
    "memberof": "unit/influx.test.js~describe37.describe44.describe74",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe74.it77",
    "access": null,
    "description": "fills in default DB",
    "lineNumber": 351,
    "importPath": "influx"
  },
  {
    "__docId__": 347,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe78",
    "testId": 78,
    "memberof": "unit/influx.test.js~describe37.describe44",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe44.describe78",
    "access": null,
    "description": ".dropContinuousQuery()",
    "lineNumber": 357,
    "importPath": "influx"
  },
  {
    "__docId__": 348,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it79",
    "testId": 79,
    "memberof": "unit/influx.test.js~describe37.describe44.describe78",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe78.it79",
    "access": null,
    "description": "queries correctly",
    "lineNumber": 358,
    "importPath": "influx"
  },
  {
    "__docId__": 349,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it80",
    "testId": 80,
    "memberof": "unit/influx.test.js~describe37.describe44.describe78",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe78.it80",
    "access": null,
    "description": "throws if DB unspecified",
    "lineNumber": 362,
    "importPath": "influx"
  },
  {
    "__docId__": 350,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it81",
    "testId": 81,
    "memberof": "unit/influx.test.js~describe37.describe44.describe78",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe78.it81",
    "access": null,
    "description": "fills in default DB",
    "lineNumber": 365,
    "importPath": "influx"
  },
  {
    "__docId__": 351,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe82",
    "testId": 82,
    "memberof": "unit/influx.test.js~describe37.describe44",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe44.describe82",
    "access": null,
    "description": ".showContinousQueries()",
    "lineNumber": 371,
    "importPath": "influx"
  },
  {
    "__docId__": 352,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it83",
    "testId": 83,
    "memberof": "unit/influx.test.js~describe37.describe44.describe82",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe82.it83",
    "access": null,
    "description": "queries correctly",
    "lineNumber": 372,
    "importPath": "influx"
  },
  {
    "__docId__": 353,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it84",
    "testId": 84,
    "memberof": "unit/influx.test.js~describe37.describe44.describe82",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe82.it84",
    "access": null,
    "description": "throws if DB unspecified",
    "lineNumber": 376,
    "importPath": "influx"
  },
  {
    "__docId__": 354,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it85",
    "testId": 85,
    "memberof": "unit/influx.test.js~describe37.describe44.describe82",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe82.it85",
    "access": null,
    "description": "fills in default DB",
    "lineNumber": 379,
    "importPath": "influx"
  },
  {
    "__docId__": 355,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe86",
    "testId": 86,
    "memberof": "unit/influx.test.js~describe37.describe44",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe44.describe86",
    "access": null,
    "description": ".writePoints()",
    "lineNumber": 385,
    "importPath": "influx"
  },
  {
    "__docId__": 356,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it87",
    "testId": 87,
    "memberof": "unit/influx.test.js~describe37.describe44.describe86",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe86.it87",
    "access": null,
    "description": "writes with all options specified without a schema",
    "lineNumber": 386,
    "importPath": "influx"
  },
  {
    "__docId__": 357,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it88",
    "testId": 88,
    "memberof": "unit/influx.test.js~describe37.describe44.describe86",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe86.it88",
    "access": null,
    "description": "writes using default options without a schema",
    "lineNumber": 405,
    "importPath": "influx"
  },
  {
    "__docId__": 358,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it89",
    "testId": 89,
    "memberof": "unit/influx.test.js~describe37.describe44.describe86",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe86.it89",
    "access": null,
    "description": "uses a schema to coerce",
    "lineNumber": 421,
    "importPath": "influx"
  },
  {
    "__docId__": 359,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it90",
    "testId": 90,
    "memberof": "unit/influx.test.js~describe37.describe44.describe86",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe86.it90",
    "access": null,
    "description": "throws on schema violations",
    "lineNumber": 440,
    "importPath": "influx"
  },
  {
    "__docId__": 360,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it91",
    "testId": 91,
    "memberof": "unit/influx.test.js~describe37.describe44.describe86",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe86.it91",
    "access": null,
    "description": "handles lack of tags",
    "lineNumber": 467,
    "importPath": "influx"
  },
  {
    "__docId__": 361,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it92",
    "testId": 92,
    "memberof": "unit/influx.test.js~describe37.describe44.describe86",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe86.it92",
    "access": null,
    "description": "handles lack of fields",
    "lineNumber": 480,
    "importPath": "influx"
  },
  {
    "__docId__": 362,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it93",
    "testId": 93,
    "memberof": "unit/influx.test.js~describe37.describe44.describe86",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe86.it93",
    "access": null,
    "description": "handles multiple tags",
    "lineNumber": 493,
    "importPath": "influx"
  },
  {
    "__docId__": 363,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it94",
    "testId": 94,
    "memberof": "unit/influx.test.js~describe37.describe44.describe86",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe86.it94",
    "access": null,
    "description": "writes with the .writeMeasurement method",
    "lineNumber": 506,
    "importPath": "influx"
  },
  {
    "__docId__": 364,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it95",
    "testId": 95,
    "memberof": "unit/influx.test.js~describe37.describe44.describe86",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe86.it95",
    "access": null,
    "description": "accepts nanoseconds (as ms)",
    "lineNumber": 521,
    "importPath": "influx"
  },
  {
    "__docId__": 365,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it96",
    "testId": 96,
    "memberof": "unit/influx.test.js~describe37.describe44.describe86",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe86.it96",
    "access": null,
    "description": "accepts timestamp overriding",
    "lineNumber": 536,
    "importPath": "influx"
  },
  {
    "__docId__": 366,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe97",
    "testId": 97,
    "memberof": "unit/influx.test.js~describe37.describe44",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe44.describe97",
    "access": null,
    "description": ".query",
    "lineNumber": 552,
    "importPath": "influx"
  },
  {
    "__docId__": 367,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it98",
    "testId": 98,
    "memberof": "unit/influx.test.js~describe37.describe44.describe97",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe97.it98",
    "access": null,
    "description": "runs raw queries",
    "lineNumber": 554,
    "importPath": "influx"
  },
  {
    "__docId__": 368,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it99",
    "testId": 99,
    "memberof": "unit/influx.test.js~describe37.describe44.describe97",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe97.it99",
    "access": null,
    "description": "parses query output",
    "lineNumber": 565,
    "importPath": "influx"
  },
  {
    "__docId__": 369,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it100",
    "testId": 100,
    "memberof": "unit/influx.test.js~describe37.describe44.describe97",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe97.it100",
    "access": null,
    "description": "selects from multiple",
    "lineNumber": 579,
    "importPath": "influx"
  },
  {
    "__docId__": 370,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it101",
    "testId": 101,
    "memberof": "unit/influx.test.js~describe37.describe44.describe97",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe97.it101",
    "access": null,
    "description": "passes in options",
    "lineNumber": 588,
    "importPath": "influx"
  },
  {
    "__docId__": 371,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it102",
    "testId": 102,
    "memberof": "unit/influx.test.js~describe37.describe44.describe97",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe97.it102",
    "access": null,
    "description": "rewrites nanosecond precisions",
    "lineNumber": 600,
    "importPath": "influx"
  },
  {
    "__docId__": 372,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe103",
    "testId": 103,
    "memberof": "unit/influx.test.js~describe37.describe44",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe44.describe103",
    "access": null,
    "description": ".createRetentionPolicy",
    "lineNumber": 613,
    "importPath": "influx"
  },
  {
    "__docId__": 373,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it104",
    "testId": 104,
    "memberof": "unit/influx.test.js~describe37.describe44.describe103",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe103.it104",
    "access": null,
    "description": "creates non-default policies",
    "lineNumber": 615,
    "importPath": "influx"
  },
  {
    "__docId__": 374,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it105",
    "testId": 105,
    "memberof": "unit/influx.test.js~describe37.describe44.describe103",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe103.it105",
    "access": null,
    "description": "creates default policies",
    "lineNumber": 624,
    "importPath": "influx"
  },
  {
    "__docId__": 375,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe106",
    "testId": 106,
    "memberof": "unit/influx.test.js~describe37.describe44",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe44.describe106",
    "access": null,
    "description": ".alterRetentionPolicy",
    "lineNumber": 634,
    "importPath": "influx"
  },
  {
    "__docId__": 376,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it107",
    "testId": 107,
    "memberof": "unit/influx.test.js~describe37.describe44.describe106",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe106.it107",
    "access": null,
    "description": "creates non-default policies",
    "lineNumber": 636,
    "importPath": "influx"
  },
  {
    "__docId__": 377,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it108",
    "testId": 108,
    "memberof": "unit/influx.test.js~describe37.describe44.describe106",
    "testDepth": 3,
    "longname": "unit/influx.test.js~describe37.describe44.describe106.it108",
    "access": null,
    "description": "creates default policies",
    "lineNumber": 645,
    "importPath": "influx"
  },
  {
    "__docId__": 378,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it109",
    "testId": 109,
    "memberof": "unit/influx.test.js~describe37.describe44",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe44.it109",
    "access": null,
    "description": "drops retention policies",
    "lineNumber": 655,
    "importPath": "influx"
  },
  {
    "__docId__": 379,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it110",
    "testId": 110,
    "memberof": "unit/influx.test.js~describe37.describe44",
    "testDepth": 2,
    "longname": "unit/influx.test.js~describe37.describe44.it110",
    "access": null,
    "description": "shows retention policies",
    "lineNumber": 660,
    "importPath": "influx"
  },
  {
    "__docId__": 380,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "unit/pool.test.js",
    "memberof": null,
    "longname": "unit/pool.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import { ExponentialBackoff } from '../../src/backoff/exponential';\nimport { Pool, RequestError, ServiceNotAvailableError } from '../../src/pool';\nimport { expect } from 'chai';\nimport * as http from 'http';\nimport * as sinon from 'sinon';\nconst hosts = 2;\ndescribe('pool', () => {\n    let pool;\n    let clock;\n    let server;\n    let sid; // random string to avoid conflicts with other running tests\n    const createPool = () => {\n        return new Pool({\n            backoff: new ExponentialBackoff({\n                initial: 300,\n                random: 0,\n                max: 10 * 1000,\n            }),\n        });\n    };\n    beforeEach(done => {\n        pool = createPool();\n        sid = `${Date.now()}${Math.random()}`; // tslint:disable-line\n        if (!process.env.WEBPACK) {\n            const handler = require('../fixture/pool-middleware');\n            server = http.createServer(handler());\n            server.listen(0, () => {\n                for (let i = 0; i < hosts; i += 1) {\n                    pool.addHost(`http://127.0.0.1:${server.address().port}`);\n                }\n                done();\n            });\n        }\n        else {\n            for (let i = 0; i < hosts; i += 1) {\n                pool.addHost(location.origin);\n            }\n            done();\n        }\n    });\n    afterEach(done => {\n        if (clock) {\n            clock.restore();\n        }\n        if (!process.env.WEBPACK) {\n            server.close(() => done());\n        }\n        else {\n            done();\n        }\n    });\n    it('attempts to make an https request', () => {\n        const p = createPool();\n        p.addHost('https://httpbin.org/get');\n        return p.json({ method: 'GET', path: '/get' });\n    });\n    describe('request generators', () => {\n        it('makes a text request', () => {\n            return pool.text({ method: 'GET', path: '/pool/json' })\n                .then(data => expect(data).to.equal('{\"ok\":true}'));\n        });\n        it('includes request query strings and bodies', () => {\n            return pool.json({\n                method: 'POST',\n                path: '/pool/echo',\n                query: { a: 42 },\n                body: 'asdf',\n            }).then(data => {\n                expect(data).to.deep.equal({\n                    query: 'a=42',\n                    body: 'asdf',\n                    method: 'POST',\n                });\n            });\n        });\n        it('discards responses', () => {\n            return pool.discard({ method: 'GET', path: '/pool/204' });\n        });\n        it('parses JSON responses', () => {\n            return pool.json({ method: 'GET', path: '/pool/json' })\n                .then(data => expect(data).to.deep.equal({ ok: true }));\n        });\n        it('errors if JSON parsing fails', () => {\n            return pool.json({ method: 'GET', path: '/pool/badjson' })\n                .then(() => { throw new Error('Expected to have thrown'); })\n                .catch(err => expect(err).to.be.an.instanceof(SyntaxError));\n        });\n    });\n    it('times out requests', () => {\n        pool.timeout = 1;\n        return pool.text({ method: 'GET', path: '/pool/json' })\n            .then(() => { throw new Error('Expected to have thrown'); })\n            .catch(err => expect(err).be.an.instanceof(ServiceNotAvailableError))\n            .then(() => pool.timeout = 10000);\n    });\n    it('retries on a request error', () => {\n        return pool.text({ method: 'GET', path: `/pool/altFail-${sid}/json` })\n            .then(body => expect(body).to.equal('{\"ok\":true}'));\n    });\n    it('fails if too many errors happen', () => {\n        expect(pool.hostIsAvailable()).to.be.true;\n        return pool.discard({ method: 'GET', path: '/pool/502' })\n            .then(() => { throw new Error('Expected to have thrown'); })\n            .catch(err => {\n            expect(err).to.be.an.instanceof(ServiceNotAvailableError);\n            expect(pool.hostIsAvailable()).to.be.false;\n        });\n    });\n    it('calls back immediately on un-retryable error', () => {\n        return pool.discard({ method: 'GET', path: '/pool/400' })\n            .then(() => { throw new Error('Expected to have thrown'); })\n            .catch(err => {\n            expect(err).to.be.an.instanceof(RequestError);\n            expect(err.res.statusCode).to.equal(400);\n            expect(pool.hostIsAvailable()).to.be.true;\n        });\n    });\n    it('pings servers', () => {\n        return pool.ping(1000, `/pool/altFail-${sid}/ping`).then(results => {\n            if (results[0].online) {\n                [results[0], results[1]] = [results[1], results[0]];\n            }\n            expect(results[0].online).to.be.false;\n            expect(results[1].online).to.be.true;\n            expect(results[1].version).to.equal('v1.0.0');\n        });\n    });\n    it('times out in pings', () => {\n        return pool.ping(1).then(results => {\n            expect(results[0].online).to.be.false;\n            expect(results[1].online).to.be.false;\n        });\n    });\n    describe('backoff', () => {\n        beforeEach(() => {\n            clock = sinon.useFakeTimers();\n            return pool.discard({ method: 'GET', path: '/pool/502' })\n                .catch(() => { });\n        });\n        it('should error if there are no available hosts', () => {\n            return pool.discard({ method: 'GET', path: '/pool/json' })\n                .then(() => { throw new Error('Expected to have thrown'); })\n                .catch(err => {\n                expect(err).to.be.an.instanceof(ServiceNotAvailableError);\n                expect(err.message).to.equal('No host available');\n            });\n        });\n        it('should reenable hosts after the backoff expires', () => {\n            expect(pool.hostIsAvailable()).to.be.false;\n            clock.tick(300);\n            expect(pool.hostIsAvailable()).to.be.true;\n        });\n        it('should back off if failures continue', () => {\n            clock.tick(300);\n            expect(pool.hostIsAvailable()).to.be.true;\n            return pool.discard({ method: 'GET', path: '/pool/502' })\n                .then(() => { throw new Error('Expected to have thrown'); })\n                .catch(err => {\n                expect(err).to.be.an.instanceof(ServiceNotAvailableError);\n                expect(pool.hostIsAvailable()).to.be.false;\n                clock.tick(300);\n                expect(pool.hostIsAvailable()).to.be.false;\n                clock.tick(300);\n                expect(pool.hostIsAvailable()).to.be.true;\n            });\n        });\n        it('should reset backoff after success', () => {\n            clock.tick(300);\n            expect(pool.hostIsAvailable()).to.be.true;\n            return pool.discard({ method: 'GET', path: '/pool/204' }).then(() => {\n                return pool.discard({ method: 'GET', path: '/pool/502' });\n            })\n                .then(() => { throw new Error('Expected to have thrown'); })\n                .catch(err => {\n                expect(err).not.to.be.undefined;\n                expect(pool.hostIsAvailable()).to.be.false;\n                clock.tick(300);\n                expect(pool.hostIsAvailable()).to.be.true;\n            });\n        });\n    });\n});\n",
    "importPath": "influx"
  },
  {
    "__docId__": 381,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe111",
    "testId": 111,
    "memberof": "unit/pool.test.js",
    "testDepth": 0,
    "longname": "unit/pool.test.js~describe111",
    "access": null,
    "description": "pool",
    "lineNumber": 7,
    "importPath": "influx"
  },
  {
    "__docId__": 382,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it112",
    "testId": 112,
    "memberof": "unit/pool.test.js~describe111",
    "testDepth": 1,
    "longname": "unit/pool.test.js~describe111.it112",
    "access": null,
    "description": "attempts to make an https request",
    "lineNumber": 52,
    "importPath": "influx"
  },
  {
    "__docId__": 383,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe113",
    "testId": 113,
    "memberof": "unit/pool.test.js~describe111",
    "testDepth": 1,
    "longname": "unit/pool.test.js~describe111.describe113",
    "access": null,
    "description": "request generators",
    "lineNumber": 57,
    "importPath": "influx"
  },
  {
    "__docId__": 384,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it114",
    "testId": 114,
    "memberof": "unit/pool.test.js~describe111.describe113",
    "testDepth": 2,
    "longname": "unit/pool.test.js~describe111.describe113.it114",
    "access": null,
    "description": "makes a text request",
    "lineNumber": 58,
    "importPath": "influx"
  },
  {
    "__docId__": 385,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it115",
    "testId": 115,
    "memberof": "unit/pool.test.js~describe111.describe113",
    "testDepth": 2,
    "longname": "unit/pool.test.js~describe111.describe113.it115",
    "access": null,
    "description": "includes request query strings and bodies",
    "lineNumber": 62,
    "importPath": "influx"
  },
  {
    "__docId__": 386,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it116",
    "testId": 116,
    "memberof": "unit/pool.test.js~describe111.describe113",
    "testDepth": 2,
    "longname": "unit/pool.test.js~describe111.describe113.it116",
    "access": null,
    "description": "discards responses",
    "lineNumber": 76,
    "importPath": "influx"
  },
  {
    "__docId__": 387,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it117",
    "testId": 117,
    "memberof": "unit/pool.test.js~describe111.describe113",
    "testDepth": 2,
    "longname": "unit/pool.test.js~describe111.describe113.it117",
    "access": null,
    "description": "parses JSON responses",
    "lineNumber": 79,
    "importPath": "influx"
  },
  {
    "__docId__": 388,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it118",
    "testId": 118,
    "memberof": "unit/pool.test.js~describe111.describe113",
    "testDepth": 2,
    "longname": "unit/pool.test.js~describe111.describe113.it118",
    "access": null,
    "description": "errors if JSON parsing fails",
    "lineNumber": 83,
    "importPath": "influx"
  },
  {
    "__docId__": 389,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it119",
    "testId": 119,
    "memberof": "unit/pool.test.js~describe111",
    "testDepth": 1,
    "longname": "unit/pool.test.js~describe111.it119",
    "access": null,
    "description": "times out requests",
    "lineNumber": 89,
    "importPath": "influx"
  },
  {
    "__docId__": 390,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it120",
    "testId": 120,
    "memberof": "unit/pool.test.js~describe111",
    "testDepth": 1,
    "longname": "unit/pool.test.js~describe111.it120",
    "access": null,
    "description": "retries on a request error",
    "lineNumber": 96,
    "importPath": "influx"
  },
  {
    "__docId__": 391,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it121",
    "testId": 121,
    "memberof": "unit/pool.test.js~describe111",
    "testDepth": 1,
    "longname": "unit/pool.test.js~describe111.it121",
    "access": null,
    "description": "fails if too many errors happen",
    "lineNumber": 100,
    "importPath": "influx"
  },
  {
    "__docId__": 392,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it122",
    "testId": 122,
    "memberof": "unit/pool.test.js~describe111",
    "testDepth": 1,
    "longname": "unit/pool.test.js~describe111.it122",
    "access": null,
    "description": "calls back immediately on un-retryable error",
    "lineNumber": 109,
    "importPath": "influx"
  },
  {
    "__docId__": 393,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it123",
    "testId": 123,
    "memberof": "unit/pool.test.js~describe111",
    "testDepth": 1,
    "longname": "unit/pool.test.js~describe111.it123",
    "access": null,
    "description": "pings servers",
    "lineNumber": 118,
    "importPath": "influx"
  },
  {
    "__docId__": 394,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it124",
    "testId": 124,
    "memberof": "unit/pool.test.js~describe111",
    "testDepth": 1,
    "longname": "unit/pool.test.js~describe111.it124",
    "access": null,
    "description": "times out in pings",
    "lineNumber": 128,
    "importPath": "influx"
  },
  {
    "__docId__": 395,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe125",
    "testId": 125,
    "memberof": "unit/pool.test.js~describe111",
    "testDepth": 1,
    "longname": "unit/pool.test.js~describe111.describe125",
    "access": null,
    "description": "backoff",
    "lineNumber": 134,
    "importPath": "influx"
  },
  {
    "__docId__": 396,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it126",
    "testId": 126,
    "memberof": "unit/pool.test.js~describe111.describe125",
    "testDepth": 2,
    "longname": "unit/pool.test.js~describe111.describe125.it126",
    "access": null,
    "description": "should error if there are no available hosts",
    "lineNumber": 140,
    "importPath": "influx"
  },
  {
    "__docId__": 397,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it127",
    "testId": 127,
    "memberof": "unit/pool.test.js~describe111.describe125",
    "testDepth": 2,
    "longname": "unit/pool.test.js~describe111.describe125.it127",
    "access": null,
    "description": "should reenable hosts after the backoff expires",
    "lineNumber": 148,
    "importPath": "influx"
  },
  {
    "__docId__": 398,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it128",
    "testId": 128,
    "memberof": "unit/pool.test.js~describe111.describe125",
    "testDepth": 2,
    "longname": "unit/pool.test.js~describe111.describe125.it128",
    "access": null,
    "description": "should back off if failures continue",
    "lineNumber": 153,
    "importPath": "influx"
  },
  {
    "__docId__": 399,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it129",
    "testId": 129,
    "memberof": "unit/pool.test.js~describe111.describe125",
    "testDepth": 2,
    "longname": "unit/pool.test.js~describe111.describe125.it129",
    "access": null,
    "description": "should reset backoff after success",
    "lineNumber": 167,
    "importPath": "influx"
  },
  {
    "__docId__": 400,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "unit/result.test.js",
    "memberof": null,
    "longname": "unit/result.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import * as results from '../../src/results';\nimport { expect } from 'chai';\ndescribe('results', () => {\n    it('parses a empty result', () => {\n        expect(results.parse({\n            results: [{\n                    series: [{\n                            name: 'test_series',\n                            columns: [\n                                'time',\n                                'mean',\n                            ],\n                            values: [],\n                        }],\n                }],\n        }).slice()).to.deep.equal([]);\n    });\n    it('parses a simple table of results', () => {\n        const r = results.parseSingle({\n            results: [{\n                    series: [{\n                            name: 'test_series',\n                            columns: [\n                                'time',\n                                'mean',\n                            ],\n                            values: [\n                                ['2016-09-25T16:12:51.787Z', 42],\n                                ['2016-09-25T16:34:31.999Z', 44],\n                            ],\n                        }],\n                }],\n        });\n        expect(r.slice()).to.deep.equal([\n            { time: new Date(1474819971787), mean: 42 },\n            { time: new Date(1474821271999), mean: 44 },\n        ]);\n        expect(r.groups()).to.deep.equal([\n            { name: 'test_series', tags: {}, rows: r.slice() },\n        ]);\n        expect(r.group({ tag: 'a' })).to.deep.equal([]);\n    });\n    it('parses alternate epochs', () => {\n        const r1 = results.parseSingle({\n            results: [{\n                    series: [{\n                            name: 'test_series',\n                            columns: [\n                                'time',\n                                'mean',\n                            ],\n                            values: [\n                                [1474819971787, 42],\n                                [1474821271999, 44],\n                            ],\n                        }],\n                }],\n        }, 'ms');\n        expect(r1.slice()).to.deep.equal([\n            { time: new Date(1474819971787), mean: 42 },\n            { time: new Date(1474821271999), mean: 44 },\n        ]);\n        const r2 = results.parseSingle({\n            results: [{\n                    series: [{\n                            name: 'test_series',\n                            columns: [\n                                'time',\n                                'mean',\n                            ],\n                            values: [\n                                [1474819971787000, 42],\n                                [1474821271999000, 44],\n                            ],\n                        }],\n                }],\n        }, 'u');\n        expect(r2.slice()).to.deep.equal([\n            { time: new Date(1474819971787), mean: 42 },\n            { time: new Date(1474821271999), mean: 44 },\n        ]);\n    });\n    it('parses grouped results', () => {\n        const r = results.parseSingle({\n            results: [{\n                    series: [{\n                            name: 'test_series',\n                            tags: { tag: 'a' },\n                            columns: [\n                                'mean',\n                            ],\n                            values: [\n                                [1],\n                                [2],\n                            ],\n                        }, {\n                            name: 'test_series',\n                            tags: { tag: 'b' },\n                            columns: [\n                                'mean',\n                            ],\n                            values: [\n                                [3],\n                                [4],\n                            ],\n                        }],\n                }],\n        });\n        expect(r.slice()).to.deep.equal([\n            { tag: 'a', mean: 1 },\n            { tag: 'a', mean: 2 },\n            { tag: 'b', mean: 3 },\n            { tag: 'b', mean: 4 },\n        ]);\n        expect(r.groups()).to.deep.equal([\n            { name: 'test_series', tags: { tag: 'a' }, rows: [{ tag: 'a', mean: 1 }, { tag: 'a', mean: 2 }] },\n            { name: 'test_series', tags: { tag: 'b' }, rows: [{ tag: 'b', mean: 3 }, { tag: 'b', mean: 4 }] },\n        ]);\n        expect(r.group({ tag: 'a' })).to.deep.equal([\n            { tag: 'a', mean: 1 },\n            { tag: 'a', mean: 2 },\n        ]);\n        expect(r.group({ tag: 'b' })).to.deep.equal([\n            { tag: 'b', mean: 3 },\n            { tag: 'b', mean: 4 },\n        ]);\n        expect(r.group({ tag: 'c' })).to.deep.equal([]);\n    });\n    it('parses empty series', () => {\n        const r1 = results.parseSingle({\n            results: [{}],\n        });\n        expect(r1.slice()).to.deep.equal([]);\n    });\n    it('parses empty values', () => {\n        const r1 = results.parseSingle({\n            results: [{\n                    series: [\n                        { columns: ['user', 'admin'] },\n                    ],\n                }],\n        });\n        expect(r1.slice()).to.deep.equal([]);\n    });\n    it('throws error on an errorful series', () => {\n        expect(() => results.parseSingle({\n            results: [\n                { error: 'user already exists' },\n            ],\n        })).to.throw(/already exists/);\n    });\n});\n",
    "importPath": "influx"
  },
  {
    "__docId__": 401,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe130",
    "testId": 130,
    "memberof": "unit/result.test.js",
    "testDepth": 0,
    "longname": "unit/result.test.js~describe130",
    "access": null,
    "description": "results",
    "lineNumber": 3,
    "importPath": "influx"
  },
  {
    "__docId__": 402,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it131",
    "testId": 131,
    "memberof": "unit/result.test.js~describe130",
    "testDepth": 1,
    "longname": "unit/result.test.js~describe130.it131",
    "access": null,
    "description": "parses a empty result",
    "lineNumber": 4,
    "importPath": "influx"
  },
  {
    "__docId__": 403,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it132",
    "testId": 132,
    "memberof": "unit/result.test.js~describe130",
    "testDepth": 1,
    "longname": "unit/result.test.js~describe130.it132",
    "access": null,
    "description": "parses a simple table of results",
    "lineNumber": 18,
    "importPath": "influx"
  },
  {
    "__docId__": 404,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it133",
    "testId": 133,
    "memberof": "unit/result.test.js~describe130",
    "testDepth": 1,
    "longname": "unit/result.test.js~describe130.it133",
    "access": null,
    "description": "parses alternate epochs",
    "lineNumber": 43,
    "importPath": "influx"
  },
  {
    "__docId__": 405,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it134",
    "testId": 134,
    "memberof": "unit/result.test.js~describe130",
    "testDepth": 1,
    "longname": "unit/result.test.js~describe130.it134",
    "access": null,
    "description": "parses grouped results",
    "lineNumber": 83,
    "importPath": "influx"
  },
  {
    "__docId__": 406,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it135",
    "testId": 135,
    "memberof": "unit/result.test.js~describe130",
    "testDepth": 1,
    "longname": "unit/result.test.js~describe130.it135",
    "access": null,
    "description": "parses empty series",
    "lineNumber": 129,
    "importPath": "influx"
  },
  {
    "__docId__": 407,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it136",
    "testId": 136,
    "memberof": "unit/result.test.js~describe130",
    "testDepth": 1,
    "longname": "unit/result.test.js~describe130.it136",
    "access": null,
    "description": "parses empty values",
    "lineNumber": 135,
    "importPath": "influx"
  },
  {
    "__docId__": 408,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it137",
    "testId": 137,
    "memberof": "unit/result.test.js~describe130",
    "testDepth": 1,
    "longname": "unit/result.test.js~describe130.it137",
    "access": null,
    "description": "throws error on an errorful series",
    "lineNumber": 145,
    "importPath": "influx"
  },
  {
    "__docId__": 409,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "unit/schema.test.js",
    "memberof": null,
    "longname": "unit/schema.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import { FieldType } from '../../src/grammar';\nimport { coerceBadly, Schema } from '../../src/schema';\nimport { expect } from 'chai';\ndescribe('schema', () => {\n    let schema;\n    beforeEach(() => {\n        schema = new Schema({\n            database: 'my_db',\n            measurement: 'my_measure',\n            tags: ['my_tag'],\n            fields: {\n                int: FieldType.INTEGER,\n                float: FieldType.FLOAT,\n                string: FieldType.STRING,\n                bool: FieldType.BOOLEAN,\n            },\n        });\n    });\n    describe('coerceBadly', () => {\n        it('apparently works', () => {\n            expect(coerceBadly({\n                b: 42,\n                a: true,\n                c: 'hello\"world',\n            })).to.deep.equal([\n                ['a', 'true'],\n                ['b', '42'],\n                ['c', '\"hello\\\\\"world\"'],\n            ]);\n        });\n    });\n    describe('basic schema', () => {\n        it('coerces data correctly', () => {\n            expect(schema.coerceFields({\n                int: 42,\n                float: 43,\n                string: 'hello\"world',\n                bool: true,\n            })).to.deep.equal([\n                ['bool', 'T'],\n                ['float', '43'],\n                ['int', '42i'],\n                ['string', '\"hello\\\\\"world\"'],\n            ]);\n        });\n        it('accepts partial data', () => {\n            expect(schema.coerceFields({\n                int: 42,\n            })).to.deep.equal([\n                ['int', '42i'],\n            ]);\n        });\n        it('coerces numeric string data', () => {\n            expect(schema.coerceFields({\n                int: '42',\n            })).to.deep.equal([\n                ['int', '42i'],\n            ]);\n        });\n        it('strips null and undefined values', () => {\n            expect(schema.coerceFields({\n                int: 42,\n                float: undefined,\n                bool: null,\n            })).to.deep.equal([\n                ['int', '42i'],\n            ]);\n        });\n        it('throws if wrong data type provided (bool)', () => {\n            expect(() => schema.coerceFields({ bool: 42 })).to.throw(/expected bool/i);\n            expect(() => schema.coerceFields({ bool: 'asdf' })).to.throw(/expected bool/i);\n        });\n        it('throws if wrong data type provided (float)', () => {\n            expect(() => schema.coerceFields({ float: true })).to.throw(/expected numeric/i);\n            expect(() => schema.coerceFields({ float: 'asdf' })).to.throw(/expected numeric/i);\n        });\n        it('throws if wrong data type provided (int)', () => {\n            expect(() => schema.coerceFields({ int: true })).to.throw(/expected numeric/i);\n            expect(() => schema.coerceFields({ int: 'asdf' })).to.throw(/expected numeric/i);\n        });\n        it('allows valid tags', () => {\n            expect(schema.checkTags({ my_tag: 'value' })).to.deep.equal(['my_tag']);\n            expect(schema.checkTags({})).to.deep.equal([]);\n        });\n        it('throws if invalid tags are provided', () => {\n            expect(() => schema.checkTags({ whatever: 'value' })).to.throw(/extraneous tags/i);\n        });\n        it('throws if invalid fields are provided', () => {\n            expect(() => expect(schema.coerceFields({ x: 42 }))).to.throw(/extraneous fields/i);\n        });\n    });\n});\n",
    "importPath": "influx"
  },
  {
    "__docId__": 410,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe138",
    "testId": 138,
    "memberof": "unit/schema.test.js",
    "testDepth": 0,
    "longname": "unit/schema.test.js~describe138",
    "access": null,
    "description": "schema",
    "lineNumber": 4,
    "importPath": "influx"
  },
  {
    "__docId__": 411,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe139",
    "testId": 139,
    "memberof": "unit/schema.test.js~describe138",
    "testDepth": 1,
    "longname": "unit/schema.test.js~describe138.describe139",
    "access": null,
    "description": "coerceBadly",
    "lineNumber": 19,
    "importPath": "influx"
  },
  {
    "__docId__": 412,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it140",
    "testId": 140,
    "memberof": "unit/schema.test.js~describe138.describe139",
    "testDepth": 2,
    "longname": "unit/schema.test.js~describe138.describe139.it140",
    "access": null,
    "description": "apparently works",
    "lineNumber": 20,
    "importPath": "influx"
  },
  {
    "__docId__": 413,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe141",
    "testId": 141,
    "memberof": "unit/schema.test.js~describe138",
    "testDepth": 1,
    "longname": "unit/schema.test.js~describe138.describe141",
    "access": null,
    "description": "basic schema",
    "lineNumber": 32,
    "importPath": "influx"
  },
  {
    "__docId__": 414,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it142",
    "testId": 142,
    "memberof": "unit/schema.test.js~describe138.describe141",
    "testDepth": 2,
    "longname": "unit/schema.test.js~describe138.describe141.it142",
    "access": null,
    "description": "coerces data correctly",
    "lineNumber": 33,
    "importPath": "influx"
  },
  {
    "__docId__": 415,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it143",
    "testId": 143,
    "memberof": "unit/schema.test.js~describe138.describe141",
    "testDepth": 2,
    "longname": "unit/schema.test.js~describe138.describe141.it143",
    "access": null,
    "description": "accepts partial data",
    "lineNumber": 46,
    "importPath": "influx"
  },
  {
    "__docId__": 416,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it144",
    "testId": 144,
    "memberof": "unit/schema.test.js~describe138.describe141",
    "testDepth": 2,
    "longname": "unit/schema.test.js~describe138.describe141.it144",
    "access": null,
    "description": "coerces numeric string data",
    "lineNumber": 53,
    "importPath": "influx"
  },
  {
    "__docId__": 417,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it145",
    "testId": 145,
    "memberof": "unit/schema.test.js~describe138.describe141",
    "testDepth": 2,
    "longname": "unit/schema.test.js~describe138.describe141.it145",
    "access": null,
    "description": "strips null and undefined values",
    "lineNumber": 60,
    "importPath": "influx"
  },
  {
    "__docId__": 418,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it146",
    "testId": 146,
    "memberof": "unit/schema.test.js~describe138.describe141",
    "testDepth": 2,
    "longname": "unit/schema.test.js~describe138.describe141.it146",
    "access": null,
    "description": "throws if wrong data type provided (bool)",
    "lineNumber": 69,
    "importPath": "influx"
  },
  {
    "__docId__": 419,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it147",
    "testId": 147,
    "memberof": "unit/schema.test.js~describe138.describe141",
    "testDepth": 2,
    "longname": "unit/schema.test.js~describe138.describe141.it147",
    "access": null,
    "description": "throws if wrong data type provided (float)",
    "lineNumber": 73,
    "importPath": "influx"
  },
  {
    "__docId__": 420,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it148",
    "testId": 148,
    "memberof": "unit/schema.test.js~describe138.describe141",
    "testDepth": 2,
    "longname": "unit/schema.test.js~describe138.describe141.it148",
    "access": null,
    "description": "throws if wrong data type provided (int)",
    "lineNumber": 77,
    "importPath": "influx"
  },
  {
    "__docId__": 421,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it149",
    "testId": 149,
    "memberof": "unit/schema.test.js~describe138.describe141",
    "testDepth": 2,
    "longname": "unit/schema.test.js~describe138.describe141.it149",
    "access": null,
    "description": "allows valid tags",
    "lineNumber": 81,
    "importPath": "influx"
  },
  {
    "__docId__": 422,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it150",
    "testId": 150,
    "memberof": "unit/schema.test.js~describe138.describe141",
    "testDepth": 2,
    "longname": "unit/schema.test.js~describe138.describe141.it150",
    "access": null,
    "description": "throws if invalid tags are provided",
    "lineNumber": 85,
    "importPath": "influx"
  },
  {
    "__docId__": 423,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it151",
    "testId": 151,
    "memberof": "unit/schema.test.js~describe138.describe141",
    "testDepth": 2,
    "longname": "unit/schema.test.js~describe138.describe141.it151",
    "access": null,
    "description": "throws if invalid fields are provided",
    "lineNumber": 88,
    "importPath": "influx"
  }
]