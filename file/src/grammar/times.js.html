<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/grammar/times.js | node-influx API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/builder.js~Expression.html">Expression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/builder.js~Measurement.html">Measurement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/index.js~InfluxDB.html">InfluxDB</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/pool.js~Pool.html">Pool</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/pool.js~RequestError.html">RequestError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/pool.js~ServiceNotAvailableError.html">ServiceNotAvailableError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/results.js~ResultError.html">ResultError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/src/doc.js~IBackoffStrategy.html">IBackoffStrategy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/src/doc.js~INanoDate.html">INanoDate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/src/doc.js~IResults.html">IResults</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-IClusterConfig">IClusterConfig</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-IPingStats">IPingStats</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-IPoint">IPoint</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-IPoolOptions">IPoolOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-IQueryOptions">IQueryOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ISchemaOptions">ISchemaOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ISingleHostConfig">ISingleHostConfig</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-IWriteOptions">IWriteOptions</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">backoff</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/backoff/exponential.js~ExponentialBackoff.html">ExponentialBackoff</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">grammar</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/grammar/ds.js~Raw.html">Raw</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-toNanoDate">toNanoDate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-escape">escape</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Precision">Precision</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-FieldType">FieldType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-FieldType">FieldType</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/grammar/times.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import { isNumeric } from &apos;./ds&apos;;
/**
 * Just a quick overview of what&apos;s going on in this file. It&apos;s a bit of a mess.
 * Influx uses three time formats:
 *  - ISO times with nanoseconds when querying where an epoch is not provided
 *  - Unix timestamps when querying with an epoch (specifying the precision
 *    in the given time unit)
 *  - Its own time format for time literals.
 *
 * To complicate matters, Influx operates on nanosecond precisions
 * by default, but we can&apos;t represent nanosecond timestamps in
 * JavaScript numbers as they&apos;re 64 bit uints.
 *
 * As a result we have several utilities to convert between these different
 * formats. When precision is required, we represent nanosecond timestamps
 * as strings and wrap default dates in the INanoDate interface which
 * lets the consumer read and write these more precise timestamps.
 *
 * Representing the timestamps as strings is definitely not a pure way to go
 * about it, but importing an arbitrary-precision integer library adds
 * bloat and is a massive hit to throughput. The operations we do do
 * are pretty trivial, so we stick with manipulating strings
 * and make sure to wash our hands when we&apos;re done.
 *
 * Vocabulary:
 *  Unix timestamp   = &apos;timestamp&apos;, abbreviated as &apos;time&apos;
 *  ISO timestamp    = &apos;ISO time&apos;, abbreviated as &apos;ISO&apos;
 *  Influx timestamp = &apos;Influx time&apos;, abbreviated as &apos;Influx&apos;
 */
function leftPad(str, length, pad = &apos;0&apos;) {
    if (typeof str === &apos;number&apos;) {
        str = String(str);
    }
    while (str.length &lt; length) {
        str = pad + str;
    }
    return str;
}
function rightPad(str, length, pad = &apos;0&apos;) {
    if (typeof str === &apos;number&apos;) {
        str = String(str);
    }
    while (str.length &lt; length) {
        str += pad;
    }
    return str;
}
/**
 * Precision is a map of available Influx time precisions.
 * @type {Object.&lt;String, String&gt;}
 * @example
 * console.log(Precision.Hours); // =&gt; &apos;h&apos;
 * console.log(Precision.Minutes); // =&gt; &apos;m&apos;
 * console.log(Precision.Seconds); // =&gt; &apos;s&apos;
 * console.log(Precision.Milliseconds); // =&gt; &apos;ms&apos;
 * console.log(Precision.Microseconds); // =&gt; &apos;u&apos;
 * console.log(Precision.Nanoseconds); // =&gt; &apos;ns&apos;
 */
export const Precision = Object.freeze({
    Hours: &apos;h&apos;,
    Microseconds: &apos;u&apos;,
    Milliseconds: &apos;ms&apos;,
    Minutes: &apos;m&apos;,
    Nanoseconds: &apos;n&apos;,
    Seconds: &apos;s&apos;,
});
class MillisecondDateManipulator {
    format(date) {
        return &apos;&quot;&apos; + leftPad(date.getUTCFullYear(), 2)
            + &apos;-&apos; + leftPad(date.getUTCMonth() + 1, 2)
            + &apos;-&apos; + leftPad(date.getUTCDate(), 2)
            + &apos; &apos; + leftPad(date.getUTCHours(), 2)
            + &apos;:&apos; + leftPad(date.getUTCMinutes(), 2)
            + &apos;:&apos; + leftPad(date.getUTCSeconds(), 2)
            + &apos;.&apos; + leftPad(date.getUTCMilliseconds(), 3) + &apos;&quot;&apos;;
    }
    toTime(date, precision) {
        let ms = date.getTime();
        switch (precision) {
            case &apos;n&apos;:
                ms *= 1000;
            case &apos;u&apos;:
                ms *= 1000;
            case &apos;ms&apos;:
                return String(ms);
            case &apos;h&apos;:
                ms /= 60;
            case &apos;m&apos;:
                ms /= 60;
            case &apos;s&apos;:
                ms /= 1000;
                return String(Math.floor(ms));
            default:
                throw new Error(`Unknown precision &apos;${precision}&apos;!`);
        }
    }
    isoToDate(timestamp) {
        return new Date(timestamp);
    }
    timetoDate(timestamp, precision) {
        switch (precision) {
            case &apos;n&apos;:
                timestamp /= 1000;
            case &apos;u&apos;:
                timestamp /= 1000;
            case &apos;ms&apos;:
                return new Date(timestamp);
            case &apos;h&apos;:
                timestamp *= 60;
            case &apos;m&apos;:
                timestamp *= 60;
            case &apos;s&apos;:
                timestamp *= 1000;
                return new Date(timestamp);
            default:
                throw new Error(`Unknown precision &apos;${precision}&apos;!`);
        }
    }
}
const nsPer = {
    ms: Math.pow(10, 6),
    s: Math.pow(10, 9),
};
function nanoIsoToTime(iso) {
    let [secondsStr, decimalStr] = iso.split(&apos;.&apos;);
    if (decimalStr === undefined) {
        decimalStr = &apos;000000000&apos;;
    }
    else {
        decimalStr = rightPad(decimalStr.slice(0, -1), 9);
        secondsStr += &apos;Z&apos;;
    }
    const seconds = Math.floor(new Date(secondsStr).getTime() / 1000);
    return `${seconds}${decimalStr}`;
}
const nanoDateMethods = {
    getNanoTimeFromISO() {
        if (!this._cachedNanoISO) {
            this._cachedNanoTime = nanoIsoToTime(this._nanoISO);
        }
        return this._cachedNanoTime;
    },
    toNanoISOStringFromISO() {
        if (!this._cachedNanoISO) {
            this._cachedNanoTime = nanoIsoToTime(this._nanoISO);
        }
        const base = this.toISOString().slice(0, -4); // slice of `123Z` milliseconds
        return `${base}${this._cachedNanoTime.slice(-9)}Z`;
    },
    getNanoTimeFromStamp() {
        return this._nanoTime;
    },
    toNanoISOStringFromStamp() {
        const base = this.toISOString().slice(0, -4); // slice of `123Z` milliseconds
        return `${base}${this._nanoTime.slice(-9)}Z`;
    },
};
/**
 * Covers a nanoseconds unix timestamp to a INanoDate for node-influx. The
 * timestamp is provided as a string to prevent precision loss.
 *
 * Please see [A Moment for Times](https://node-influx.github.io/manual/
 * usage.html#a-moment-for-times) for a more complete and eloquent explanation
 * of time handling in this module.
 *
 * @param {String} timestamp
 * @returns {INanoDate}
 * @example
 * const date = toNanoDate(&apos;1475985480231035600&apos;)
 *
 * // You can use the returned Date as a normal date:
 * expect(date.getTime()).to.equal(1475985480231);
 *
 * // We decorate it with two additional methods to read
 * // nanosecond-precision results:
 * expect(date.getNanoTime()).to.equal(&apos;1475985480231035600&apos;);
 * expect(date.toNanoISOString()).to.equal(&apos;2016-10-09T03:58:00.231035600Z&apos;);
 */
export function toNanoDate(timestamp) {
    const date = new Date(Math.floor(Number(timestamp) / nsPer.ms));
    date._nanoTime = timestamp;
    date.getNanoTime = nanoDateMethods.getNanoTimeFromStamp;
    date.toNanoISOString = nanoDateMethods.toNanoISOStringFromStamp;
    return date;
}
function asNanoDate(date) {
    const d = date;
    if (d.getNanoTime) {
        return d;
    }
    return undefined;
}
class NanosecondsDateManipulator {
    format(date) {
        return &apos;&quot;&apos; + leftPad(date.getUTCFullYear(), 2)
            + &apos;-&apos; + leftPad(date.getUTCMonth() + 1, 2)
            + &apos;-&apos; + leftPad(date.getUTCDate(), 2)
            + &apos; &apos; + leftPad(date.getUTCHours(), 2)
            + &apos;:&apos; + leftPad(date.getUTCMinutes(), 2)
            + &apos;:&apos; + leftPad(date.getUTCSeconds(), 2)
            + &apos;.&apos; + date.getNanoTime().slice(-9) + &apos;&quot;&apos;;
    }
    toTime(date, precision) {
        let ms = date.getTime();
        switch (precision) {
            case &apos;u&apos;:
                return date.getNanoTime().slice(0, -3);
            case &apos;n&apos;:
                return date.getNanoTime();
            case &apos;h&apos;:
                ms /= 60;
            case &apos;m&apos;:
                ms /= 60;
            case &apos;s&apos;:
                ms /= 1000;
            case &apos;ms&apos;:
                return String(Math.floor(ms));
            default:
                throw new Error(`Unknown precision &apos;${precision}&apos;!`);
        }
    }
    isoToDate(timestamp) {
        const date = new Date(timestamp);
        date._nanoISO = timestamp;
        date.getNanoTime = nanoDateMethods.getNanoTimeFromISO;
        date.toNanoISOString = nanoDateMethods.toNanoISOStringFromISO;
        return date;
    }
    timetoDate(timestamp, precision) {
        switch (precision) {
            case &apos;h&apos;:
                timestamp *= 60;
            case &apos;m&apos;:
                timestamp *= 60;
            case &apos;s&apos;:
                timestamp *= 1000;
            case &apos;ms&apos;:
                timestamp *= 1000;
            case &apos;u&apos;:
                timestamp *= 1000;
            case &apos;n&apos;:
                const date = new Date(timestamp / nsPer.ms);
                date._nanoTime = String(timestamp);
                date.getNanoTime = nanoDateMethods.getNanoTimeFromStamp;
                date.toNanoISOString = nanoDateMethods.toNanoISOStringFromStamp;
                return date;
            default:
                throw new Error(`Unknown precision &apos;${precision}&apos;!`);
        }
    }
}
const milliManipulator = new MillisecondDateManipulator();
const nanoManipulator = new NanosecondsDateManipulator();
/**
 * formatDate converts the Date instance to Influx&apos;s date query format.
 * @private
 */
export function formatDate(date) {
    const nano = asNanoDate(date);
    if (nano) {
        return nanoManipulator.format(nano);
    }
    else {
        return milliManipulator.format(date);
    }
}
/**
 * Converts a Date instance to a timestamp with the specified time precision.
 * @private
 */
export function dateToTime(date, precision) {
    const nano = asNanoDate(date);
    if (nano) {
        return nanoManipulator.toTime(nano, precision);
    }
    else {
        return milliManipulator.toTime(date, precision);
    }
}
/**
 * Converts an ISO-formatted data or unix timestamp to a Date instance. If
 * the precision is finer than &apos;ms&apos; the returned value will be a INanoDate.
 * @private
 */
export function isoOrTimeToDate(stamp, precision = &apos;n&apos;) {
    if (typeof stamp === &apos;string&apos;) {
        return nanoManipulator.isoToDate(stamp);
    }
    else {
        return nanoManipulator.timetoDate(stamp, precision);
    }
}
/**
 * Converts a timestamp to a string with the correct precision. Assumes
 * that raw number and string instances are already in the correct precision.
 * @private
 */
export function castTimestamp(timestamp, precision) {
    if (typeof timestamp === &apos;string&apos;) {
        if (!isNumeric(timestamp)) {
            throw new Error(`Expected numeric value for, timestamp, but got &apos;${timestamp}&apos;!`);
        }
        return timestamp;
    }
    if (typeof timestamp === &apos;number&apos;) {
        return String(timestamp);
    }
    return dateToTime(timestamp, precision);
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.8)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
